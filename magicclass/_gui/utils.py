from __future__ import annotations

from typing import Any, TYPE_CHECKING, Callable, TypeVar
from typing_extensions import deprecated
from types import FunctionType
from magicgui.widgets import FunctionGui, Widget
from magicgui.types import Undefined
from magicgui.type_map import get_widget_class
from magicgui.signature import magic_signature, MagicParameter

from macrokit import Symbol
from magicclass._exceptions import MagicClassConstructionError
from magicclass.signature import split_annotated_type

if TYPE_CHECKING:
    from ._base import BaseGui
    from magicgui.widgets import FileEdit


def get_parameters(fgui: FunctionGui):
    return {k: v.default for k, v in fgui.__signature__.parameters.items()}


_C = TypeVar("_C", bound=type)

TYPES_IGNORE: tuple[type, ...] = (property, classmethod, staticmethod, deprecated)


def copy_class(cls: _C, ns: str, name: str) -> _C:
    """
    Copy a class in a new namespace.

    This function not only copies the class object but also update all the
    `__qualname__` recursively.

    Parameters
    ----------
    cls : type
        Class to be copied.
    ns : type
        New namespace (the qualname of parent class) of `cls`.
    name : str
        New name of `cls`.

    Returns
    -------
    type
        Copied class object.
    """
    from magicclass.wrappers import abstractapi
    from magicclass.utils.qthreading import thread_worker

    namespace = {}
    qualname = f"{ns}.{name}"
    for key, attr in cls.__dict__.items():
        if key == "__original_class__":
            continue
        if isinstance(attr, (FunctionType, abstractapi, thread_worker)):
            if attr.__qualname__.split("<locals>.")[-1].count(".") == 0:
                pass
            else:
                attr.__qualname__ = f"{qualname}.{key}"
        elif isinstance(attr, type):
            attr = copy_class(attr, qualname, attr.__qualname__.split(".")[-1])
        namespace[key] = attr
    out = type(cls.__name__, cls.__bases__, namespace)
    out.__qualname__ = qualname
    out.__original_class__ = getattr(cls, "__original_class__", cls)
    return out


def format_error(
    e: Exception,
    hist: list[tuple[str, str, str]],
    name: str,
    attr: Any,
):
    hist_str = (
        "\n\t".join(map(lambda x: f"{x[0]} {x[1]} -> {x[2]}", hist))
        + f"\n\t\t{name} ({type(attr)}) <--- Error"
    )
    if not hist_str.startswith("\n\t"):
        hist_str = "\n\t" + hist_str
    if isinstance(e, MagicClassConstructionError):
        e.args = (f"\n{hist_str}\n{e}",)
        raise e
    else:
        tb = e.__traceback__
        construction_err = MagicClassConstructionError(
            f"\n{hist_str}\n\n{type(e).__name__}: {e}"
        ).with_traceback(tb)
        raise construction_err from None


def connect_magicclasses(parent: BaseGui, child: BaseGui, child_name: str):
    """Connect magicclass parent/child."""

    child.__magicclass_parent__ = parent
    parent.__magicclass_children__.add(child)
    child._my_symbol = Symbol(child_name)


def callable_to_classes(f: Callable) -> list[tuple[type[Widget], MagicParameter]]:
    """Get list of classes that will be generated by the magicgui type map."""
    sig = magic_signature(f)
    return [(_parameter_to_widget_class(p), p) for p in sig.parameters.values()]


def show_dialog_from_mgui(mgui: FunctionGui):
    """Show file dialog from given magicgui widget."""
    fdialog: FileEdit = mgui[0]
    if result := fdialog._show_file_dialog(
        fdialog.mode,
        caption=fdialog._btn_text,
        start_path=str(fdialog.value),
        filter=fdialog.filter,
    ):
        fdialog.value = result
        out = mgui(result)
    else:
        out = None
    return out


TZ_EMPTY = "__no__default__"


def _parameter_to_widget_class(param: MagicParameter):
    value = Undefined if param.default in (param.empty, TZ_EMPTY) else param.default
    annotation, options = split_annotated_type(param.annotation)
    options = options.copy()
    wdg_class, _ = get_widget_class(value, annotation, options, raise_on_unknown=False)
    return wdg_class
