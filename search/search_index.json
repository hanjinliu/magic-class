{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"magic-class","text":"<p><code>magic-class</code> makes GUI development as easy as daily coding by converting well-typed Python class directly into GUI. It is powered by magicgui and has a smooth interface with napari. <code>magic-class</code> is also implemented with useful widgets such as <code>matplotlib</code> figure canvas, logger widget and color edit.</p>"},{"location":"#source","title":"Source","text":"<p>\u2192 Jump to GitHub repository.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>magic-class</code> is available on PyPI.</p> <pre><code>pip install magic-class\n</code></pre>"},{"location":"#contents","title":"Contents","text":"<ul> <li>Quick Start</li> <li>Basics</li> <li>Make Your GUI Better</li> <li>Data Visualization</li> <li>Advanced Topics</li> <li>Best Practice</li> </ul>"},{"location":"best_practice/","title":"Best Practice","text":"<p>Here's some tips that will be useful for better GUI design.</p>"},{"location":"best_practice/#shared-input-parameters","title":"Shared Input Parameters","text":"<p>If you want to control input parameters outside each <code>magicgui</code> widget, the example below is the most naive implementation.</p> <pre><code>from magicclass import magicclass, magicmenu, field, abstractapi, set_design\n\n@magicclass\nclass Main:\n    @magicmenu\n    class Menu:\n        add = abstractapi()\n        sub = abstractapi()\n\n    a = field(float)\n    b = field(float)\n    result = field(float, record=False)\n\n    @set_design(location=Menu)\n    def add(self):\n        \"\"\"Add two values\"\"\"\n        self.result.value = self.a.value + self.b.value\n\n    @set_design(location=Menu)\n    def sub(self):\n        \"\"\"Subtract two values\"\"\"\n        self.result.value = self.a.value - self.b.value\n</code></pre> <p>However, after you calculated \"4.0 + 2.0\" and \"6.0 - 3.0\", macro will be recorded like</p> <pre><code>ui.a.value = 4.0\nui.b.value = 2.0\nui.add()\nui.a.value = 6.0\nui.b.value = 3.0\nui.sub()\n</code></pre> <p>This is perfectly reproducible but is not user friendly. If users want to run functions programmatically, they'll prefer styles like <code>add(1, 2)</code>. Unfriendliness is more obvious when you changed the values of <code>a</code> and <code>b</code> alternately many times before adding them and saw its macro recorded like</p> macro<pre><code>ui.a.value = 3.0\nui.b.value = 1.0\nui.a.value = 6.0\nui.b.value = 2.0\nui.a.value = 9.0\nui.b.value = 3.0\nui.add()\n</code></pre> <p>To avoid this, you can use the \"bind\" option.</p> <pre><code>from typing import Annotated\nfrom magicclass import magicclass, magicmenu, field\n\n@magicclass\nclass Main:\n    @magicmenu\n    class Menu:\n        add = abstractapi()\n        sub = abstractapi()\n\n    a = field(float, record=False)  # &lt;- don't record\n    b = field(float, record=False)  # &lt;- don't record\n    result = field(float, record=False)\n\n    @set_design(location=Menu)\n    def add(self, a: Annotated[float, {\"bind\": a}], b: Annotated[float, {\"bind\": b}]):\n        \"\"\"Add two values\"\"\"\n        self.result.value = a + b\n\n    @set_design(location=Menu)\n    def sub(self, a: Annotated[float, {\"bind\": a}], b: Annotated[float, {\"bind\": b}]):\n        \"\"\"Subtract two values\"\"\"\n        self.result.value = a - b\n</code></pre> <p>Widget created by this code works completely identical to the previous one. Also, macro will be recorded in a better way.</p> macro<pre><code>ui.add(a=4.0, b=2.0)\nui.sub(a=6.0, b=3.0)\n</code></pre>"},{"location":"quick_start/","title":"Quick Start","text":""},{"location":"quick_start/#basics","title":"Basics","text":"<p>In <code>magicgui</code>, you can convert functions into widgets. For instance,</p> <pre><code>from magicgui import magicgui\n\n@magicgui\ndef print_text(text: str):\n    print(text)\n\nprint_text.show()\n</code></pre> <p>will create a widget that is composed of a line edit (for the input argument <code>text</code>) and a call button.</p> <p>Similarly, with <code>magicclass</code> decorator, you can convert a Python class into a <code>magicgui</code>'s <code>Container</code> widget and its methods appear as push buttons. When a button is clicked, the corresponding magicgui will be popped up.</p> <pre><code>from magicclass import magicclass\n\n@magicclass\nclass MyClass:\n    def set_value(self, value: str):\n        self.value = value\n\n    def print_value(self):\n        print(self.value)\n\nui = MyClass()\nui.show()\n</code></pre> <p></p> <p>Note</p> <p>Methods whose names start with \"_\" are considered as private functions so that they will not be converted into widgets.</p> <p>Note</p> <p><code>ui.print_value</code> is a method, and <code>ui[\"print_value\"]</code> is a button widget. To get the <code>FunctionGui</code> widget, use <code>get_function_gui</code> function.</p> <pre><code>from magicclass import get_function_gui\n\nprint(get_function_gui(ui.print_value))\n</code></pre> <p>With exactly the same class design, you can also create a menu bar, a context menu or a tool bar, using <code>@magicmenu</code>, <code>@magiccontext</code> and <code>@magictoolbar</code> respectively. See here for more details.</p>"},{"location":"quick_start/#use-other-widgets-in-magic-class","title":"Use Other Widgets in magic-class","text":"<p>Other <code>magicgui</code>'s widgets can also be used inside magic-classes by using <code>field</code>.</p> <pre><code>from magicgui.widgets import LineEdit, Slider\nfrom magicclass import magicclass, field\n\n@magicclass\nclass MyClass:\n    s = field(LineEdit, label=\"Name:\")\n    i = field(Slider, label=\"Age:\", options={\"max\": 100})\n\n    def print(self):\n        print(f\"{self.s.value} ({self.i.value})\")\n\nui = MyClass()\nui.show()\n</code></pre> <p></p> <p>If a method is decorated with <code>@magicgui</code>, it will directly added in the container widget, in place of a push button. This is natural because decorated methods are no longer functions, but <code>FunctionGui</code> widgets.</p> <pre><code>from magicgui import magicgui\nfrom magicclass import magicclass\n\n@magicclass\nclass MyClass:\n    @magicgui\n    def input_parameters(self, s: str, i: int):\n        self.s = s\n        self.i = i\n\n    def print(self):\n        print(f\"{self.s} ({self.i})\")\n\nui = MyClass()\nui.show()\n</code></pre> <p></p>"},{"location":"quick_start/#gui-specific-settings","title":"GUI-specific Settings","text":"<p>In :mod:<code>magicclass</code>, GUI-specific settings are defined by decorators to keep code tidy.</p> <p>\"GUI-specific settings\" include</p> <ul> <li>Widget options (such as the limits of a slider)</li> <li>Widget designs (such as the text of a button)</li> <li>Whether to be recorded to macro.</li> </ul>"},{"location":"quick_start/#parameter-options","title":"Parameter Options","text":"<p>In <code>magicgui</code> you can define parameter options with keyword arguments:</p> <pre><code>@magicgui(a={\"widget_type\": \"Slider\", \"step\": 10})\ndef f(a: int): ...\n</code></pre> <p>However, magic classes need another way to do this because <code>magicgui</code> will never be called by users.</p> <p><code>magicclass</code> uses <code>set_options</code> decorator instead.</p> <pre><code>from magicclass import magicclass, set_options\n\n@magicclass\nclass Main:\n    @set_options(a={\"widget_type\": \"Slider\", \"step\": 10})\n    def f(self, a: int): ...\n\nui = Main()\nui.show()\n</code></pre> <p></p>"},{"location":"quick_start/#change-button-designs","title":"Change Button Designs","text":"<p>Aside from those options of <code>magicgui</code> popup widget to run functions, you may also want to change the design of button itself. <code>magicclass</code> uses <code>set_design</code> decorator to do this.</p> <pre><code>from magicclass import magicclass, set_design\n\n@magicclass\nclass Main:\n    @set_design(text=\"Click (if you want)\", min_height=120)\n    def f(self): ...\n\nui = Main()\nui.show()\n</code></pre> <p></p>"},{"location":"quick_start/#post-initialization","title":"Post Initialization","text":"<p>Widgets are constructed only after <code>__init__</code> is called. To change widget designs or geometries, you should not call those methods in <code>__init__</code> because they are not constructed yet.</p> <p>Similar to the builtin <code>dataclass</code>, <code>__post_init__</code> method is used as the post initalization procedure. It is called after widget is completely built.</p> <pre><code>@magicclass\nclass Main:\n    def __init__(self):\n        # self[\"func\"] &lt;-- this is not correct. Button \"func\" is not ready!\n        ...\n\n    def __post_init__(self):\n        self[\"func\"].min_height = 100\n\n    def func(self): ...\n</code></pre>"},{"location":"quick_start/#code-completion","title":"Code Completion","text":"<p>A problem of using decorators to overwrite classes is code completion. When you are coding, the classes do not inherits magic classes yet, so IDE and console don't know they will have attributes such as <code>self.parent_viewer</code> or <code>self.name</code>.</p> <p>All the magic classes inherits <code>MagicTemplate</code> class. This class is designed in a way which does not interfere with magic class decorators, while provides enough information of typings and annotations.</p> <pre><code>from magicclass import magicclass, MagicTemplate\n\n@magicclass\nclass MyClass(MagicTemplate): # inherit here\n    ...\n</code></pre>"},{"location":"quick_start/#macro-recording","title":"Macro Recording","text":"<p>Another outstanding feature of magic class is its macro recorder functionalities. Function calls and value changes in child widgets are all recorded and you can generate executable Python script at any time.</p> <p>Recorded macro is stored in the <code>macro</code> attribute. You can generate Python script as string just by passing it to <code>str</code>.</p> <pre><code>macro_string = str(ui.macro)\nprint(macro_string)\n</code></pre> <p>A macro editor widget is always tagged at <code>macro.widget</code>. It is a <code>magicgui</code> widget so you can open it by <code>show()</code> method or directly append it to GUI.</p> <pre><code>ui.macro.widget.show() # show widget as a separate window.\nui.append(ui.macro.widget) # append macro as a child widget.\n</code></pre> <p>By default, the script shown in the macro editor is synchronized, that is, automatically updated whenever macro itself is updated.</p> <p>You may want some functions not to record macro (such as a function that only shows some information). It could also be redundant to record value changes of some widgets. You can prevent macro recording with <code>do_not_record</code> decorator for methods (or <code>record=False</code> argument for fields).</p> <pre><code>from magicclass import magicclass, do_not_record\n\n@magicclass\nclass Main:\n    @do_not_record\n    def f(self):\n        \"\"\"this function will never be recorded\"\"\"\n\nui = Main()\nui.show()\n</code></pre>"},{"location":"quick_start/#build-command-palette-widget-automatically","title":"Build Command Palette Widget Automatically","text":"<p>Command palette is very useful if you have many functions and widgets in your UI. Since each magic-class instance is well organized, you can build a command palette widget without any additional effort.</p> <p>To use this feature, you need to install qt-command-palette package.</p> <pre><code>pip install qt-command-palette\n</code></pre> <p>You may want to use the command palette with the <code>bind_key</code> decorator.</p> <pre><code>from magicclass import magicclass, magicmenu, bind_key\nfrom magicclass.command_palette import exec_command_palette\n\n@magicclass\nclass Main:\n    # many functions and widgets here.\n    @magicmenu\n    class SubClass:\n        def func_sub(self): ...\n\n    def func(self): ...\n\n    @bind_key(\"Ctrl+Shift+P\")\n    def _show_palette(self):\n        exec_command_palette(self)\n</code></pre> <p>In the example above, two commands <code>Main: func</code> and <code>Main.SubClass: func sub</code> will be registered.</p>"},{"location":"quick_start/#add-functions-after-construction","title":"Add Functions after Construction","text":"<p>Making a button or menu action dynamically is also useful, especially when you already have a UI platform but you still want some extensions like plugin system. You don't have to worry about that since magic class construction itself is dynamic. Just <code>append</code> well-typed functions to magic class object.</p> <pre><code>def new_function(i: int, s: str):\n    ...\n\nui.append(new_function) # then a proper widget appears in the GUI\n</code></pre> <p>Note</p> <p>If you want to convert the function into a menu action, your code will look like this.</p> <pre><code>@magicclass\nclass A:\n    @magicmenu\n    class Menu:\n        ...\n\nui = A()\nui.Menu.append(new_function)\n</code></pre>"},{"location":"advanced/","title":"Advanced Topics","text":"<ul> <li>Convert QtWidgets into a Magic Widget</li> <li>Customize Macro Recording</li> <li>Inherit Magic Class</li> </ul>"},{"location":"advanced/customize_macro/","title":"Customize Macro Recording","text":"<p>Magic class depends its macro recording functionalities on macro-kit. To customize macro recording, you can use functions and methods in <code>macrokit</code>.</p>"},{"location":"advanced/customize_macro/#define-how-to-record-objects","title":"Define How to Record Objects","text":"<p><code>macrokit</code> does not record all the values as strings because the string form of a value could be very long (such as an image data). To define a rule of how to record a certain type of objects, you can use <code>register_type</code> function (actually this is how <code>magic-class</code> registers <code>Path</code> and <code>Enum</code> to make macro compatible with type mapping rules of <code>magicgui</code>).</p> <pre><code>from macrokit import register_type\n</code></pre> <p><code>register_type</code> takes two arguments: a type to register and a function. You have to define the conversion rule in the second argument. The example below shows how to record <code>numpy.ndarray</code> in the standard <code>np.array([...])</code> style.</p> <pre><code>import numpy as numpy\n\n@register_type(np.ndarray)\ndef numpy_to_str(arr):\n    return f\"np.array({arr.tolist()})\"\n</code></pre>"},{"location":"advanced/freewidget/","title":"Convert QtWidgets into a Magic Widget","text":"<p>If your are an experienced GUI developper, you may often want to define your own Qt widget classes. Still, it is a good idea to convert it into a <code>magicgui</code>'s widget in terms of API consistency and simplicity. Especially if you intend to make your GUI accessible via Python interpreter, hiding huge number of methods defined in <code>QWidget</code> class is very important for code completion and safety.</p> <p>The easiest way to do that in <code>magicclass</code> is to inherit <code>FreeWidget</code>. It is aimed at constructing a <code>magicgui.widgets.Widget</code> object with custom Qt widget. Actually, many widgets in <code>magicclass.widgets</code> are defined in this way.</p>"},{"location":"advanced/freewidget/#basic-usage","title":"Basic Usage","text":"<p>Suppose you have a Qt widget defined like:</p> <pre><code>from qtpy.QtWidgets import QWidget\n\nclass MyQWidget(QWidget):\n    ...\n</code></pre> <p>To convert it into a <code>magicgui</code>'s widget, you'll have to call <code>set_widget</code> method after initializing the super class.</p> <pre><code>from magicclass.widgets import FreeWidget\n\nclass MyWidget(FreeWidget):\n    def __init__(self):\n        super().__init__()  # initialize\n        self.wdt = MyQWidget()  # construct Qt widget\n        self.set_widget(self.wdt)  # set widget\n</code></pre> <p>Now the <code>MyQWidget</code> object is correctly imported into <code>magicgui.widgets.Widget</code> and is ready to used as if it is an ordinary <code>magicgui</code>'s widget.</p> <pre><code>x = MyWidget()\n\n# properties and methods inherited from \"Widget\"\nx.visible = False\nx.enabled = True\nx.show()\nx.hide()\n\n# append into a container\nfrom magicgui.widgets import Container\ncontainer = Container()\ncontainer.append(x)\n</code></pre>"},{"location":"advanced/freewidget/#make-it-behave-more-like-a-valuewidget","title":"Make It Behave More Like A ValueWidget","text":"<p><code>magicgui.widgets.ValueWidget</code> is widgets that have representative values. You'll have to define <code>value</code> property to make a <code>FreeWidget</code> more like a <code>ValueWidget</code>. It is better idea to add a value change signal to the class.</p> <p>Following example shows how to define value getter/setter and value change signal, suppose the <code>MyQWidget</code> has methods <code>value</code>, <code>setValue</code> and the corresponding signal <code>valueChanged</code>.</p> <pre><code>from psygnal import Signal\n\nclass MyWidget(FreeWidget):\n    # you should restrict the type of signal emission according to the Qt widget,\n    # such as Signal(str)\n    changed = Signal(object)\n\n    def __init__(self):\n        super().__init__()  # initialize\n        self.wdt = MyQWidget()  # construct Qt widget\n        self.wdt.valueChanged.connect(self.changed.emit)  # relay signal\n        self.set_widget(self.wdt)  # set widget\n\n    @property\n    def value(self):\n        return self.wdt.value()\n\n    @value.setter\n    def value(self, v):\n        self.wdt.setValue(v)\n</code></pre>"},{"location":"advanced/inheritance/","title":"Inherit Magic Class","text":"<p>Class inheritance is fundamental in object-oriented languages. It makes class definition much clearer in many cases.</p> <p>Magic-class is designed to make GUI structures connected with the structure of class itself, so how to deal with class inheritance is not a well-defined feature by default. Here are some points that you have to keep in mind before making abstract classes.</p>"},{"location":"advanced/inheritance/#the-order-of-widget","title":"The Order of Widget","text":"<p>First, let's see following example. It is obvious that created GUI will have two buttons named \"common function\" and \"main function\", but it is not clear which is upper and which is lower.</p> <p>In magic-class, methods defined in base classes will appear upper than those in subclasses. In the case of the example below, buttons will be arranged in order \"common function\", \"main function\".</p> <pre><code>from magicclass import magicclass\n\nclass Base:\n    def common_function(self):\n        \"\"\"Do some common things.\"\"\"\n\n@magicclass\nclass Main(Base):\n    def main_function(self):\n        \"\"\"Main one.\"\"\"\n\nui = Main()\nui.show()\n</code></pre> <p></p> <p>Warning</p> <p>Do NOT decorate <code>Base</code> class with <code>@magicclass</code>, otherwise constructor will raise <code>TypeError</code>. You only have to decorate the final concrete classes.</p>"},{"location":"advanced/inheritance/#field-objects-in-the-base-class","title":"Field Objects in the Base Class","text":"<p>You may want to add widgets using fields. Fields behave similarly as methods. In the following example, Two widgets, <code>x</code> and <code>y</code> will be packed in the <code>Main</code> GUI, in order <code>x</code>, <code>y</code>.</p> <pre><code>from magicclass import magicclass, field\n\nclass Base:\n    x = field(\"this is x, appearing first\")\n\n@magicclass\nclass Main(Base):\n    y = field(\"this is y, appearing second\")\n\nui = Main()\nui.show()\n</code></pre> <p></p> <p>However, if you want to use \"bind\" to bind values to method or connect callback function to a field, you must re-define fields in the subclasses.</p>"},{"location":"advanced/inheritance/#1-bind-methods-or-fields","title":"1. Bind methods or fields","text":"<p>This will not work</p> <pre><code>from typing import Annotated\nfrom magicclass import magicclass, field\n\nclass Base:\n    x = field(int)\n\n@magicclass\nclass Main(Base):\n    def func(self, value: Annotated[int, {\"bind\": x}]):\n        \"\"\"Do something\"\"\"\n</code></pre> <p>This will work</p> <pre><code>from magicclass import magicclass, field\nfrom magicclass.types import Bound\n\nclass Base:\n    x = field(int)\n\n@magicclass\nclass Main(Base):\n    x = field(int)\n\n    def func(self, value: Annotated[int, {\"bind\": x}]):\n        \"\"\"Do something\"\"\"\n</code></pre>"},{"location":"advanced/inheritance/#1-define-callbacks","title":"1. Define Callbacks","text":"<p>This will not work</p> <pre><code>from magicclass import magicclass, field\n\nclass Base:\n    x = field(int)\n\n@magicclass\nclass Main(Base):\n    @x.connect\n    def _callback(self):\n        \"\"\"Do something\"\"\"\n</code></pre> <p>This will work</p> <pre><code>from magicclass import magicclass, field\n\nclass Base:\n    x = field(int)\n\n@magicclass\nclass Main(Base):\n    x = field(int)\n\n    @x.connect\n    def _callback(self):\n        \"\"\"Do something\"\"\"\n</code></pre> <p>Note</p> <p>These caveats are quite natural considering the concept of scope in Python. When you define a variable in a class, it is not available from other classes until class definition finishes.</p> <pre><code>class A:\n    x = 1\nclass B(A):\n    print(x)\n</code></pre> Output<pre><code>NameError: name 'x' is not defined\n</code></pre> <p>This is because class inheritance has not finished yet in the line <code>print(x)</code>.</p>"},{"location":"advanced/inheritance/#nesting-magic-classes","title":"Nesting Magic Classes","text":"<p>Nesting magic classes is useful for designing layout of widgets. You don't have to worry about inheriting base class with a nested magic class.</p> <pre><code>from magicclass import magicclass, MagicTemplate, field, set_design\n\nclass Base(MagicTemplate):\n    # All of these widgets and their layout will be inherited to subclasses\n    result = field(str)\n\n    @magicclass\n    class X(MagicTemplate):\n        def func(self): ...\n\n    @set_design(location=X)\n    def func(self):\n        self.result.value = self.__class__.__name__\n\n@magicclass\nclass A(Base):\n    pass\n</code></pre>"},{"location":"advanced/inheritance/#predefinition-of-methods-and-fields","title":"Predefinition of Methods and Fields","text":"<p>Most of the time you want to inherit a class is when you want to prepare a template of multipule GUIs. As mentioned above, methods and fields that are defined in the base class will packed before those in the subclasses. This is not desirable if you want the subclasses share same header and footer and make the middle widgets variable.</p> <p>Just like using <code>location=...</code> argument, the pre-definition strategy is also useful here. First arrange all the widgets in the base class, and specifically define the real widgets in the subclasses.</p> <pre><code>from magicclass import magicclass, MagicTemplate, field, set_design, abstractapi\n\nclass Base(MagicTemplate):\n    header = field(\"this is header\", widget_type=\"Label\")\n    x = abstractapi()  # pre-definition\n    footer = field(\"this is footer\", widget_type=\"Label\")\n\n@magicclass\nclass A(Base):\n    def x(self):\n        \"\"\"Do something\"\"\"\n\n@magicclass\nclass B(Base):\n    x = field(int)\n\n@magicclass(layout=\"horizontal\")\nclass Main(MagicTemplate):\n    a = field(A)\n    b = field(B)\n\nui = Main()\nui.show()\n</code></pre> <p></p>"},{"location":"api/core/","title":"magicclass.core","text":""},{"location":"api/core/#magicclass.core.Parameters","title":"<code>Parameters</code>","text":"Source code in <code>magicclass\\core.py</code> <pre><code>class Parameters:\n    def __init__(self):\n        self.__name__ = self.__class__.__name__\n        self.__qualname__ = self.__class__.__qualname__\n\n        sig = [\n            inspect.Parameter(name=\"self\", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD)\n        ]\n        for name, attr in inspect.getmembers(self):\n            if name.startswith(\"__\") or callable(attr):\n                continue\n            sig.append(\n                inspect.Parameter(\n                    name=name,\n                    kind=inspect.Parameter.POSITIONAL_OR_KEYWORD,\n                    default=attr,\n                )\n            )\n        if hasattr(self.__class__, \"__annotations__\"):\n            annot = self.__class__.__annotations__\n            for name, t in annot.items():\n                sig.append(\n                    inspect.Parameter(\n                        name=name,\n                        kind=inspect.Parameter.POSITIONAL_OR_KEYWORD,\n                        annotation=t,\n                    )\n                )\n\n        self.__signature__ = inspect.Signature(sig)\n\n    def __call__(self, *args) -&gt; None:\n        params = list(self.__signature__.parameters.keys())[1:]\n        for a, param in zip(args, params):\n            setattr(self, param, a)\n\n    def as_dict(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Convert parameter fields into a dictionary.\n\n        &gt;&gt;&gt; class params(Parameters):\n        &gt;&gt;&gt;     i = 1\n        &gt;&gt;&gt;     j = 2\n\n        &gt;&gt;&gt; p = params()\n        &gt;&gt;&gt; p.as_dict() # {\"i\": 1, \"j\": 2}\n        \"\"\"\n        params = list(self.__signature__.parameters.keys())[1:]\n        return {param: getattr(self, param) for param in params}\n</code></pre>"},{"location":"api/core/#magicclass.core.Parameters.as_dict","title":"<code>as_dict()</code>","text":"<p>Convert parameter fields into a dictionary.</p> <p>class params(Parameters):     i = 1     j = 2</p> <p>p = params() p.as_dict() # {\"i\": 1, \"j\": 2}</p> Source code in <code>magicclass\\core.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert parameter fields into a dictionary.\n\n    &gt;&gt;&gt; class params(Parameters):\n    &gt;&gt;&gt;     i = 1\n    &gt;&gt;&gt;     j = 2\n\n    &gt;&gt;&gt; p = params()\n    &gt;&gt;&gt; p.as_dict() # {\"i\": 1, \"j\": 2}\n    \"\"\"\n    params = list(self.__signature__.parameters.keys())[1:]\n    return {param: getattr(self, param) for param in params}\n</code></pre>"},{"location":"api/core/#magicclass.core.build_help","title":"<code>build_help(ui, parent=None)</code>","text":"<p>Build a widget for user guide. Once it is built, widget will be cached.</p> <p>Parameters:</p> Name Type Description Default <code>ui</code> <code>MagicTemplate</code> <p>Magic class UI object.</p> required <p>Returns:</p> Type Description <code>HelpWidget</code> <p>Help of the input UI.</p> Source code in <code>magicclass\\core.py</code> <pre><code>def build_help(ui: MagicTemplate, parent=None) -&gt; HelpWidget:\n    \"\"\"\n    Build a widget for user guide. Once it is built, widget will be cached.\n\n    Parameters\n    ----------\n    ui : MagicTemplate\n        Magic class UI object.\n\n    Returns\n    -------\n    HelpWidget\n        Help of the input UI.\n    \"\"\"\n    ui_id = id(ui)\n    if ui_id in _HELPS.keys():\n        help_widget = _HELPS[ui_id]\n    else:\n        from .help import HelpWidget\n\n        if parent is None:\n            parent = ui.native\n        help_widget = HelpWidget(ui, parent=parent)\n        _HELPS[ui_id] = help_widget\n    return help_widget\n</code></pre>"},{"location":"api/core/#magicclass.core.get_button","title":"<code>get_button(ui, name=None, *, cache=False)</code>","text":"<p>Get the button/action object for the given method.</p> <p>This function is a helper function for magicclass. Using this method is always safer than directly accessing it by <code>ui[\"method\"]</code>. Either of following expression is allowed.</p> <p>get_button(ui, \"method\") get_button(ui.method)</p> Source code in <code>magicclass\\core.py</code> <pre><code>def get_button(\n    ui: MagicTemplate | MethodType,\n    name: str | None = None,\n    *,\n    cache: bool = False,\n) -&gt; Clickable:\n    \"\"\"\n    Get the button/action object for the given method.\n\n    This function is a helper function for magicclass. Using this method is\n    always safer than directly accessing it by ``ui[\"method\"]``.\n    Either of following expression is allowed.\n\n    &gt;&gt;&gt; get_button(ui, \"method\")\n    &gt;&gt;&gt; get_button(ui.method)\n\n    \"\"\"\n    if name is None:\n        if hasattr(ui, \"__self__\") and callable(ui):\n            func = ui\n            ui = func.__self__\n            name = func.__name__\n        else:\n            raise TypeError(\n                \"The first argument of `get_button() must be a method if \"\n                \"the method name is not given.\"\n            )\n    cache_key = (id(ui), name)\n    if cache and (btn := _BUTTON_CACHE.get(cache_key, None) is not None):\n        return btn\n\n    widget: Clickable = ui[name]\n\n    if not hasattr(widget, \"mgui\"):\n        raise TypeError(f\"Widget {widget} does not have FunctionGui inside it.\")\n\n    if widget._unwrapped:\n        from magicclass.signature import get_additional_option\n\n        opt = get_additional_option(getattr(ui, name), \"into\", None)\n        if opt is not None:\n            for _, child_instance in ui._iter_child_magicclasses():\n                _name = child_instance.__class__.__name__\n                if _name == opt:\n                    widget = child_instance[name]\n                    return widget\n            raise ValueError(f\"Could not find {opt} in {ui}.\")\n    if cache:\n        _BUTTON_CACHE[cache_key] = widget\n    return widget\n</code></pre>"},{"location":"api/core/#magicclass.core.get_function_gui","title":"<code>get_function_gui(ui, name=None)</code>","text":"<p>Get the FunctionGui object hidden beneath push button or menu action.</p> <p>This function is a helper function for magicclass. Using this method is always safer than directly accessing it by <code>ui[\"method\"].mgui</code>. Either of following expression is allowed.</p> <p>get_function_gui(ui, \"method\") get_function_gui(ui.method)</p> Source code in <code>magicclass\\core.py</code> <pre><code>def get_function_gui(\n    ui: MagicTemplate | MethodType,\n    name: str | None = None,\n) -&gt; FunctionGuiPlus:\n    \"\"\"\n    Get the FunctionGui object hidden beneath push button or menu action.\n\n    This function is a helper function for magicclass. Using this method is\n    always safer than directly accessing it by ``ui[\"method\"].mgui``.\n    Either of following expression is allowed.\n\n    &gt;&gt;&gt; get_function_gui(ui, \"method\")\n    &gt;&gt;&gt; get_function_gui(ui.method)\n\n    \"\"\"\n    if name is None:\n        if hasattr(ui, \"__self__\") and callable(ui):\n            func = ui\n            ui = func.__self__\n            name = func.__name__\n        else:\n            raise TypeError(\n                \"The first argument of `get_function_gui() must be a method if \"\n                \"the method name is not given.\"\n            )\n    else:\n        func = getattr(ui, name)\n    widget: Clickable = ui[name]\n\n    if not hasattr(widget, \"mgui\"):\n        raise TypeError(f\"Widget {widget} does not have FunctionGui inside it.\")\n\n    if widget.mgui is not None:\n        return widget.mgui\n\n    from ._gui._base import _build_mgui, _create_gui_method\n\n    func = _create_gui_method(ui, func)\n    mgui = _build_mgui(widget, func, ui)\n    return mgui\n</code></pre>"},{"location":"api/core/#magicclass.core.magicclass","title":"<code>magicclass(class_=None, *, layout='vertical', labels=True, name=None, visible=None, close_on_run=None, popup_mode=None, error_mode=None, widget_type=WidgetType.none, icon=None, stylesheet=None, properties=None, record=True, symbol='ui')</code>","text":"<p>Decorator that can convert a Python class into a widget.</p> <p>@magicclass class C:     ... ui = C() ui.show()  # open GUI</p> <p>Parameters:</p> Name Type Description Default <code>class_</code> <code>type</code> <p>Class to be decorated.</p> <code>None</code> <code>layout</code> <code>(str, 'vertical' or 'horizontal')</code> <p>Layout of the main widget.</p> <code>is \"vertical\"</code> <code>labels</code> <code>bool</code> <p>If true, magicgui labels are shown.</p> <code>is True</code> <code>name</code> <code>str</code> <p>Name of GUI.</p> <code>None</code> <code>visible</code> <code>bool</code> <p>Initial visibility of GUI. Useful when magic class is nested.</p> <code>None</code> <code>close_on_run</code> <code>bool</code> <p>If True, magicgui created by every method will be deleted after the method is completed without exceptions, i.e. magicgui is more like a dialog.</p> <code>is True</code> <code>popup_mode</code> <code>str or PopUpMode</code> <p>Option of how to popup FunctionGui widget when a button is clicked.</p> <code>is PopUpMode.popup</code> <code>error_mode</code> <code>str or ErrorMode</code> <p>Option of how to raise errors during function calls.</p> <code>is ErrorMode.msgbox</code> <code>widget_type</code> <code>WidgetType or str</code> <p>Widget type of container.</p> <code>none</code> <code>icon</code> <code>Any</code> <p>Path to the icon image or any object that can be converted into an icon.</p> <code>None</code> <code>stylesheet</code> <code>str or StyleSheet object</code> <p>Set stylesheet to the widget if given.</p> <code>None</code> <code>properties</code> <code>dict</code> <p>Set properties to the widget if given. This argument is useful when you want to set width, height or margin without defining post_init.</p> <code>None</code> <code>record</code> <code>bool</code> <p>If True, macro recording is enabled.</p> <code>is True</code> <code>symbol</code> <code>str</code> <p>The identifier used in macro to represent this widget.</p> <code>is \"ui\"</code> <p>Returns:</p> Type Description <code>Decorated class or decorator.</code> Source code in <code>magicclass\\core.py</code> <pre><code>def magicclass(\n    class_: type | None = None,\n    *,\n    layout: str = \"vertical\",\n    labels: bool = True,\n    name: str = None,\n    visible: bool | None = None,\n    close_on_run: bool = None,\n    popup_mode: PopUpModeStr | PopUpMode = None,\n    error_mode: ErrorModeStr | ErrorMode = None,\n    widget_type: WidgetTypeStr | WidgetType = WidgetType.none,\n    icon: Any | None = None,\n    stylesheet: str | StyleSheet = None,\n    properties: dict[str, Any] = None,\n    record: bool = True,\n    symbol: str = \"ui\",\n):\n    \"\"\"\n    Decorator that can convert a Python class into a widget.\n\n    &gt;&gt;&gt; @magicclass\n    &gt;&gt;&gt; class C:\n    &gt;&gt;&gt;     ...\n    &gt;&gt;&gt; ui = C()\n    &gt;&gt;&gt; ui.show()  # open GUI\n\n    Parameters\n    ----------\n    class_ : type, optional\n        Class to be decorated.\n    layout : str, \"vertical\" or \"horizontal\", default is \"vertical\"\n        Layout of the main widget.\n    labels : bool, default is True\n        If true, magicgui labels are shown.\n    name : str, optional\n        Name of GUI.\n    visible : bool, optional\n        Initial visibility of GUI. Useful when magic class is nested.\n    close_on_run : bool, default is True\n        If True, magicgui created by every method will be deleted after the method is\n        completed without exceptions, i.e. magicgui is more like a dialog.\n    popup_mode : str or PopUpMode, default is PopUpMode.popup\n        Option of how to popup FunctionGui widget when a button is clicked.\n    error_mode : str or ErrorMode, default is ErrorMode.msgbox\n        Option of how to raise errors during function calls.\n    widget_type : WidgetType or str, optional\n        Widget type of container.\n    icon : Any, optional\n        Path to the icon image or any object that can be converted into an icon.\n    stylesheet : str or StyleSheet object, optional\n        Set stylesheet to the widget if given.\n    properties : dict, optional\n        Set properties to the widget if given. This argument is useful when you want\n        to set width, height or margin without defining __post_init__.\n    record : bool, default is True\n        If True, macro recording is enabled.\n    symbol : str, default is \"ui\"\n        The identifier used in macro to represent this widget.\n\n    Returns\n    -------\n    Decorated class or decorator.\n    \"\"\"\n    if popup_mode is None:\n        popup_mode = defaults[\"popup_mode\"]\n    if close_on_run is None:\n        close_on_run = defaults[\"close_on_run\"]\n    if error_mode is None:\n        error_mode = defaults[\"error_mode\"]\n\n    if isinstance(widget_type, str):\n        widget_type = widget_type.lower()\n\n    widget_type = WidgetType(widget_type)\n\n    def wrapper(cls) -&gt; type[ClassGui]:\n        if not isinstance(cls, type):\n            raise TypeError(f\"magicclass can only wrap classes, not {type(cls)}\")\n\n        class_gui = _TYPE_MAP[widget_type]\n\n        if not issubclass(cls, MagicTemplate):\n            check_override(cls)\n\n        # get class attributes first\n        doc = cls.__doc__\n        sig = inspect.signature(cls)\n        annot = cls.__dict__.get(\"__annotations__\", {})\n        mod = cls.__module__\n        qualname = cls.__qualname__\n\n        new_attrs = convert_attributes(cls, hide=class_gui.__mro__, record=record)\n        oldclass = type(cls.__name__ + _BASE_CLASS_SUFFIX, (cls,), {})\n        newclass = type(cls.__name__, (class_gui, oldclass), new_attrs)\n\n        newclass.__signature__ = sig\n        newclass.__doc__ = doc\n        newclass.__module__ = mod\n        newclass.__qualname__ = qualname\n\n        # concatenate annotations\n        newclass.__annotations__ = class_gui.__annotations__.copy()\n        newclass.__annotations__.update(annot)\n\n        @functools_wraps(oldclass.__init__)\n        def __init__(self: MagicTemplate, *args, **kwargs):\n            # Without \"app = \" Jupyter freezes after closing the window!\n            app = get_app()\n\n            gui_kwargs = dict(\n                layout=layout,\n                labels=labels,\n                name=name or cls.__name__,\n                visible=visible,\n                close_on_run=close_on_run,\n                popup_mode=PopUpMode(popup_mode),\n                error_mode=ErrorMode(error_mode),\n            )\n\n            # Inheriting Container's constructor is the most intuitive way.\n            if kwargs and \"__init__\" not in cls.__dict__:\n                gui_kwargs.update(kwargs)\n                kwargs = {}\n\n            class_gui.__init__(self, **gui_kwargs)\n\n            with self.macro.blocked():\n                super(oldclass, self).__init__(*args, **kwargs)\n\n            self._convert_attributes_into_widgets()\n\n            if widget_type in (WidgetType.collapsible, WidgetType.button):\n                self.text = self.name\n\n            if icon:\n                self.icon = icon\n            if stylesheet:\n                self.native.setStyleSheet(str(stylesheet))\n            if hasattr(self, \"__post_init__\"):\n                with self.macro.blocked():\n                    self.__post_init__()\n            if properties:\n                for k, v in properties.items():\n                    setattr(self, k, v)\n            self._my_symbol = _as_symbol(symbol)\n\n        newclass.__init__ = __init__\n\n        # Users may want to override repr\n        newclass.__repr__ = oldclass.__repr__\n\n        return newclass\n\n    if class_ is None:\n        return wrapper\n    else:\n        return wrapper(class_)\n</code></pre>"},{"location":"api/core/#magicclass.core.magiccontext","title":"<code>magiccontext(class_=None, *, into=None, close_on_run=None, popup_mode=None, error_mode=None, labels=True, name=None, icon=None, record=True)</code>","text":"<p>Decorator that converts a Python class into a context menu.</p> Source code in <code>magicclass\\core.py</code> <pre><code>def magiccontext(\n    class_: type = None,\n    *,\n    into: Callable | None = None,\n    close_on_run: bool = None,\n    popup_mode: str | PopUpMode = None,\n    error_mode: str | ErrorMode = None,\n    labels: bool = True,\n    name: str | None = None,\n    icon: Any | None = None,\n    record: bool = True,\n):\n    \"\"\"Decorator that converts a Python class into a context menu.\"\"\"\n\n    if popup_mode is None:\n        popup_mode = defaults[\"popup_mode\"]\n    if close_on_run is None:\n        close_on_run = defaults[\"close_on_run\"]\n    if error_mode is None:\n        error_mode = defaults[\"error_mode\"]\n\n    if popup_mode in (\n        PopUpMode.above,\n        PopUpMode.below,\n        PopUpMode.first,\n        PopUpMode.last,\n    ):\n        raise ValueError(f\"Mode {popup_mode.value} is not compatible with Menu.\")\n\n    def wrapper(cls) -&gt; type[ContextMenuGui]:\n        if not isinstance(cls, type):\n            raise TypeError(f\"magicclass can only wrap classes, not {type(cls)}\")\n\n        if not issubclass(cls, MagicTemplate):\n            check_override(cls)\n\n        # get class attributes first\n        doc = cls.__doc__\n        sig = inspect.signature(cls)\n        mod = cls.__module__\n        qualname = cls.__qualname__\n\n        new_attrs = convert_attributes(cls, hide=ContextMenuGui.__mro__, record=record)\n        oldclass = type(cls.__name__ + _BASE_CLASS_SUFFIX, (cls,), {})\n        newclass = type(cls.__name__, (ContextMenuGui, oldclass), new_attrs)\n\n        newclass.__signature__ = sig\n        newclass.__doc__ = doc\n        newclass.__module__ = mod\n        newclass.__qualname__ = qualname\n\n        @functools_wraps(oldclass.__init__)\n        def __init__(self: MagicTemplate, *args, **kwargs):\n            # Without \"app = \" Jupyter freezes after closing the window!\n            app = get_app()\n\n            gui_kwargs = dict(\n                close_on_run=close_on_run,\n                popup_mode=PopUpMode(popup_mode),\n                error_mode=ErrorMode(error_mode),\n                labels=labels,\n                name=name or cls.__name__,\n            )\n\n            # Inheriting Container's constructor is the most intuitive way.\n            if kwargs and \"__init__\" not in cls.__dict__:\n                gui_kwargs.update(kwargs)\n                kwargs = {}\n\n            ContextMenuGui.__init__(self, **gui_kwargs)\n\n            with self.macro.blocked():\n                super(oldclass, self).__init__(*args, **kwargs)\n\n            self._convert_attributes_into_widgets()\n\n            if icon:\n                self.icon = icon\n            if hasattr(self, \"__post_init__\"):\n                with self.macro.blocked():\n                    self.__post_init__()\n            if into is not None:\n                from .signature import upgrade_signature\n\n                upgrade_signature(into, additional_options={\"context_menu\": self})\n\n        newclass.__init__ = __init__\n\n        # Users may want to override repr\n        newclass.__repr__ = oldclass.__repr__\n\n        return newclass\n\n    return wrapper if class_ is None else wrapper(class_)\n</code></pre>"},{"location":"api/core/#magicclass.core.magicmenu","title":"<code>magicmenu(class_=None, *, close_on_run=None, popup_mode=None, error_mode=None, labels=True, name=None, icon=None, record=True)</code>","text":"<p>Decorator that converts a Python class into a menu bar.</p> Source code in <code>magicclass\\core.py</code> <pre><code>def magicmenu(\n    class_: type = None,\n    *,\n    close_on_run: bool = None,\n    popup_mode: str | PopUpMode = None,\n    error_mode: str | ErrorMode = None,\n    labels: bool = True,\n    name: str | None = None,\n    icon: Any | None = None,\n    record: bool = True,\n):\n    \"\"\"Decorator that converts a Python class into a menu bar.\"\"\"\n    return _call_magicmenu(**locals(), menugui_class=MenuGui)\n</code></pre>"},{"location":"api/core/#magicclass.core.magictoolbar","title":"<code>magictoolbar(class_=None, *, close_on_run=None, popup_mode=None, error_mode=None, labels=True, name=None, icon=None, record=True)</code>","text":"<p>Decorator that converts a Python class into a menu bar.</p> Source code in <code>magicclass\\core.py</code> <pre><code>def magictoolbar(\n    class_: type = None,\n    *,\n    close_on_run: bool = None,\n    popup_mode: str | PopUpMode = None,\n    error_mode: str | ErrorMode = None,\n    labels: bool = True,\n    name: str | None = None,\n    icon: Any | None = None,\n    record: bool = True,\n):\n    \"\"\"Decorator that converts a Python class into a menu bar.\"\"\"\n    return _call_magicmenu(**locals(), menugui_class=ToolBarGui)\n</code></pre>"},{"location":"api/core/#magicclass.core.repeat","title":"<code>repeat(ui, index=-1)</code>","text":"<p>Repeat last operation on GUI using recorded macro.</p> <p>Parameters:</p> Name Type Description Default <code>ui</code> <code>MagicTemplate</code> <p>Target magic-class widget.</p> required <code>index</code> <code>int</code> <p>Which execution will be repeated. Any object that support list slicing can be used. By default the last operation will be repeated.</p> <code>is -1</code> Source code in <code>magicclass\\core.py</code> <pre><code>def repeat(ui: MagicTemplate, index: int = -1) -&gt; None:\n    \"\"\"\n    Repeat last operation on GUI using recorded macro.\n\n    Parameters\n    ----------\n    ui : MagicTemplate\n        Target magic-class widget.\n    index : int, default is -1\n        Which execution will be repeated. Any object that support list slicing can be used.\n        By default the last operation will be repeated.\n    \"\"\"\n    warnings.warn(\n        \"repeat() is deprecated and will be removed soon. Use `ui.macro.repeat_method()` \"\n        \"to specify call options in more detail.\",\n        DeprecationWarning,\n    )\n    line = ui.macro[index]\n    try:\n        line.eval({\"ui\": ui})\n    except Exception as e:\n        msg = e.args[0]\n        msg = f\"Caused by &gt;&gt;&gt; {line}. {msg}\"\n        raise e\n    return None\n</code></pre>"},{"location":"api/core/#magicclass.core.update_widget_state","title":"<code>update_widget_state(ui, macro=None)</code>","text":"<p>Update widget values based on a macro.</p> <p>This helper function works similar to the <code>update_widget</code> method of <code>FunctionGui</code>. In most cases, this function will be used for restoring a state from a macro recorded before. Value changed signal will not be emitted within this operation.</p> <p>Parameters:</p> Name Type Description Default <code>ui</code> <code>MagicTemplate</code> <p>Magic class instance.</p> required <code>macro</code> <code>Macro or str</code> <p>An executable macro or string that dictates how GUI will be updated.</p> <code>None</code> Source code in <code>magicclass\\core.py</code> <pre><code>def update_widget_state(ui: MagicTemplate, macro: Macro | str | None = None) -&gt; None:\n    \"\"\"\n    Update widget values based on a macro.\n\n    This helper function works similar to the ``update_widget`` method of ``FunctionGui``.\n    In most cases, this function will be used for restoring a state from a macro recorded\n    before. Value changed signal will not be emitted within this operation.\n\n    Parameters\n    ----------\n    ui : MagicTemplate\n        Magic class instance.\n    macro : Macro or str, optional\n        An executable macro or string that dictates how GUI will be updated.\n    \"\"\"\n    from macrokit import Head, Macro\n\n    if macro is None:\n        macro = ui.macro\n    elif isinstance(macro, str):\n        s = macro\n        macro = Macro()\n        for line in s.split(\"\\n\"):\n            macro.append(line)\n    elif not isinstance(macro, Macro):\n        raise TypeError(\n            f\"The second argument must be a Macro or str, got {type(macro)}.\"\n        )\n\n    for expr in macro:\n        if expr.head is Head.call:\n            # ui.func(...)\n            fname = str(expr.at(0, 1))\n            args, kwargs = expr.eval_call_args()\n            if fname.startswith(\"_\"):\n                if fname != \"_call_with_return_callback\":\n                    continue\n                fgui = get_function_gui(ui, args[0])\n\n            else:\n                fgui = get_function_gui(ui, fname)\n\n            with fgui.changed.blocked():\n                for key, value in kwargs.items():\n                    getattr(fgui, key).value = value\n\n        elif expr.head is Head.assign:\n            # ui.field.value = ...\n            # ui.vfield = ...\n            expr.eval({}, {str(ui._my_symbol): ui})\n\n    return None\n</code></pre>"},{"location":"basics/","title":"Basics","text":"<p>Here's some basics for widget creation in <code>magic-class</code>.</p> <ul> <li>Options in magic-class</li> <li>Nest magic-classes</li> <li>Use Fields in magic-class</li> <li>Serialize/Deserialize GUI</li> <li>Use magicproperty in magic-class</li> <li>Set Tooltips</li> </ul>"},{"location":"basics/fields/","title":"Use Fields in magic-class","text":""},{"location":"basics/fields/#magicfields","title":"MagicFields","text":""},{"location":"basics/fields/#basics","title":"Basics","text":"<p>When widgets are directly provided in a magic class as class variables, they should be considered as \"fields\". The concept of fields was actually introduced in Python as an standard library <code>dataclasses</code> as a <code>Field</code> object. A field is in a state of \"ready to be converted into a object\", i.e., a new object is created for every instance construction.</p> <pre><code>from dataclasses import dataclass, field\n\n@dataclass\nclass C:\n    i: int = field(default=5)\n    s: str = field(default_factory=str)\n\nc = C()\nc\n</code></pre> Output<pre><code>C(i=5, s='')\n</code></pre> <p>Here, the arguments <code>default</code> and <code>default_factory</code> are reminiscent of \"default value\" and \"type annotation\" in <code>magicgui</code>. To apply the concept of field to widget construction, <code>magic-class</code> has <code>MagicField</code>, which can store defaults as an object that is ready to be converted into a widget.</p> <pre><code>from magicclass import field\n\nfld = field(str, options={\"value\": \"initial\"})\nwidget = fld.to_widget()\nwidget\n</code></pre> <p></p> <p><code>field</code> can be used very similar to the <code>create_widget</code> fucntion in <code>magicgui</code>.</p> <pre><code>field(int, widget_type=\"Slider\", options={\"max\": 10})\n</code></pre> <p>The first argument of <code>field</code> can be type, value or widget type.</p> <pre><code>from magicclass import magicclass, field\nfrom magicgui.widgets import Table\n\n@magicclass\nclass MyClass:\n    i = field(int)\n    s = field(\"abc\")\n    table = field(Table)\n\nui = MyClass()\nui.show()\n</code></pre> <p></p>"},{"location":"basics/fields/#define-callbacks","title":"Define Callbacks","text":"<p>Another feature of widgets are their ability to emit signals upon state changes. In <code>magicgui</code>, most of them have the same API <code>widget.changed.connect(callback)</code>. Owing to the simplicity, callback functions can be safely bound to <code>MagicField</code> with <code>connect</code> method.</p> <pre><code>from magicclass import magicclass, field\n\n@magicclass\nclass MyClass:\n    a = field(int)\n\n    @a.connect\n    def _callback(self):\n        print(\"value changed!\")\n</code></pre>"},{"location":"basics/fields/#make-fields-more-property-like","title":"Make Fields More Property-like","text":"<p>In many cases, you don't need all the controls of a widget. If you only need the value of a field, you might not want to get the value via <code>self.widget.value</code> all the way.</p> <p>Magic-class provides another field class called <code>MagicValueField</code>, which returns the value itself when the field get accessed. You can create <code>MagicValueField</code> object using <code>vfield</code> function. You can also defined callbacks similar to <code>MagicField</code>.</p> <pre><code>from magicclass import magicclass, vfield\n\n@magicclass\nclass MyClass:\n    a = vfield(int)\n\n    @a.connect\n    def _callback(self):\n        print(\"value changed!\")\n\n    def print_value(self):\n        print(f\"a = {self.a}\")  # instead of \"self.a.value\"!\n</code></pre>"},{"location":"basics/fields/#even-better-widget-configuration","title":"Even better widget configuration","text":"<p><code>MagicField</code> and <code>MagicValueField</code> can be configured with <code>options</code> keyword argument. However, passing a <code>dict</code> is not good for code readability and typing.</p> <p>An alternative but more recommended way is to use <code>with_options</code> method.</p> <pre><code>from magicclass import magicclass, vfield\n\n@magicclass\nclass MyClass:\n\n    a = vfield(int, options={\"min\": 0, \"max\": 10})  # instead of this\n    a = vfield(int).with_options(min=0, max=10)  # use this\n\n    def print_value(self):\n        print(f\"a = {self.a}\")\n</code></pre> <p>If you only want to set <code>choices</code>, <code>with_choices</code> method is provided for this purpose.</p> <pre><code>from magicclass import magicclass, vfield\n\n@magicclass\nclass MyClass:\n\n    a = vfield(options={\"choices\": [1, 2, 3]})  # instead of this\n    a = vfield().with_options(choices=[1, 2, 3])  # or this\n    a = vfield().with_choices([1, 2, 3])  # you can use this\n\n    def print_value(self):\n        print(f\"a = {self.a}\")\n</code></pre> <p>Using <code>with_choices</code> is not just a shortcut. It also properly predicts the type of the output widget.</p>"},{"location":"basics/fields/#advanced-fieldgroup","title":"(Advanced) FieldGroup","text":"<p>A <code>FieldGroup</code> is a class that is used as a container of field objects and behave like a <code>field</code> or <code>vfield</code> function itself.</p> <pre><code>from magicclass import FieldGroup, vfield\n\nclass Points(FieldGroup):\n    x = vfield(float)\n    y = vfield(float)\n\n@magicclass\nclass A:\n    # FieldGroup is a direct subclass of Container\n    points = Points(layout=\"horizontal\", labels=False)\n\n    def get_point(self):\n        print(self.points.x, self.points.y)\n\nui = A()\nui.show()\n</code></pre> <p></p> <p>Here, a <code>Points</code> class has two child fields <code>x</code> and <code>y</code>. Since they are created by <code>vfield</code>, their values can be simply obtained by <code>self.points.x</code>.</p>"},{"location":"basics/fields/#deal-with-widgets-and-values","title":"Deal with Widgets and Values","text":"<p>Basically, a <code>FieldGroup</code> can always be substituted with a <code>magicclass</code>. However, there are some benefits to use <code>FieldGroup</code> over creating <code>magicclass</code>.</p> <p>A <code>FieldGroup</code> is aware of its child fields. Even if you defined all the fields using <code>vfield</code> you can still retrieve the widgets via <code>widgets</code> property.</p> <pre><code>from magicclass import FieldGroup, vfield\n\nclass Points(FieldGroup):\n    x = vfield(float)\n    y = vfield(float)\n\n@magicclass\nclass A:\n    points = Points(layout=\"horizontal\", labels=False)\n\nui = A()\n</code></pre> <p></p> <p>When you want the values of points, you just have to do what you used to do.</p> <pre><code>ui.points.x  # get the value of x\n</code></pre> <p>When you have to directly use the widget (<code>FloatSpinBox</code> in this example) of <code>x</code>, following code works.</p> <pre><code>ui.points.widgets.x  # get the widget of x\n</code></pre>"},{"location":"basics/fields/#create-many-similar-containers","title":"Create Many Similar Containers","text":"<p>Since a <code>FieldGroup</code> can be considered as a \"widget creator\", you can easily define a widget template by subclassing it.</p> <pre><code>class LabeledLineEdit(FieldGroup):\n    lbl = vfield(widget_type=\"Label\")\n    txt = vfield(str)\n\n    def __init__(self, label_text=\"label\"):\n        super().__init__(labels=False)\n        self.lbl = label_text\n\n# Now, `LabeledLineEdit` can be used similar to `field` or `vfield`.\n\n@magicclass\nclass A:\n    text_1 = LabeledLineEdit(\"First name\")\n    text_2 = LabeledLineEdit(\"Last name\")\n\nui = A()\nui.show()\n</code></pre> <p></p>"},{"location":"basics/fields/#advanced-use-fields-in-non-gui-classes","title":"(Advanced) Use Fields in Non-GUI Classes","text":""},{"location":"basics/fields/#hasfields-trait","title":"HasFields trait","text":"<p><code>MagicField</code> and <code>FieldGroup</code> are also designed for general usage of widgets. This means that essentially you can use <code>vfield</code> instead of <code>property</code> for getting or setting parameters.</p> <pre><code>class A:\n    x = vfield(int)\n\na = A()\na.x = 10  # OK\na.x  # Out: 10\n</code></pre> <p>However, a problem here is that there is no simple way to obtain the widget of <code>x</code>. Of course you can use <code>field</code> instead of <code>vfield</code> to make the widget accessible but you will have to get the value from <code>a.x.value</code>, which is not elegant.</p> <p>As mentioned above, this problem is solved in <code>FieldGroup</code> by <code>widgets</code> property. Therefore, the inaccessibility of widgets can generally be solved in a similar way.</p> <p>The <code>widgets</code> interface becomes available by subclassing <code>HasFields</code> class.</p> <pre><code>from magicclass import HasFields\n\nclass A(HasFields):\n    x = vfield(int)\n\na = A()\na.x = 10  # OK\na.x  # Out: 10\na.widgets.x  # SpinBox\n</code></pre> <p>Note</p> <p>Actually, <code>FieldGroup</code> is also a subclass of <code>HasFields</code>.</p>"},{"location":"basics/nest/","title":"Nest magic-classes","text":""},{"location":"basics/nest/#basics","title":"Basics","text":"<p>Magic classes can be nested. During magic class construction, when a magic class encountered another magic class object, the child object is appended to the parent.</p> <pre><code>from magicclass import magicclass\n\n@magicclass(layout=\"horizontal\")\nclass Frame1:\n    def first_a(self): ...\n    def first_b(self): ...\n\n@magicclass(layout=\"horizontal\")\nclass Frame2:\n    def second_a(self): ...\n    def second_b(self): ...\n    def second_c(self): ...\n\n@magicclass\nclass Main:\n    frame1 = Frame1()\n    frame2 = Frame2()\n\nui = Main()\nui.show()\n</code></pre> <p>You can also directly define the child classes inside the parent.</p> <pre><code>from magicclass import magicclass\n\n@magicclass\nclass Main:\n    @magicclass(layout=\"horizontal\")\n    class Frame1:\n        def first_a(self): ...\n        def first_b(self): ...\n\n    @magicclass(layout=\"horizontal\")\n    class Frame2:\n        def second_a(self): ...\n        def second_b(self): ...\n        def second_c(self): ...\n\nui = Main()\nui.show()\n</code></pre> <p></p>"},{"location":"basics/nest/#make-menus-using-nesting-strategy","title":"Make Menus Using Nesting Strategy","text":"<p>To make multi-functional widgets, we usually want to use a menu bar to categorize functions. The <code>@magicmenu</code> decorator provides a consistent API to implement a menu bar as a standard magic class.</p> <pre><code>from magicclass import magicclass, magicmenu\n\n@magicclass\nclass Main:\n    @magicmenu\n    class File:\n        @magicmenu\n        class New:\n            def first_a(self): ...\n            def first_b(self): ...\n        def Open(self): ...\n        def Close(self): ...\n\n    @magicmenu\n    class Edit:\n        ...\n\nui = Main()\nui.show()\n</code></pre> <p></p> <p>If multiple menus are defined in tandem, they will all added to the menu bar.</p> <p>Same strategy also works for right-click context menu.</p> <pre><code>from magicclass import magicclass, magiccontext\n\n@magicclass\nclass Main:\n    @magiccontext\n    class ContextMenu:\n        def Copy(self): ...\n        def Paste(self): ...\n        @magiccontext\n        class Others:\n            def function_a(self): ...\n            def function_b(self): ...\n            def function_c(self): ...\n\nui = Main()\nui.show()\n</code></pre> <p></p>"},{"location":"basics/nest/#make-toolbar","title":"Make Toolbar","text":"<p>Similar to menus, magic class also provide a toolbar widget with same API. <code>@magictoolbar</code> is the decorator for toolbar.</p> <pre><code>from magicclass import magicclass, magictoolbar\n\n@magicclass\nclass Main:\n    @magictoolbar\n    class ToolBar:\n        def a(self): ...\n        def b(self): ...\n        def c(self): ...\n\nui = Main()\nui.show()\n</code></pre> <p></p> <p>If multiple toolbars are defined in tandem, they will split by tabs.</p>"},{"location":"basics/options/","title":"Options in magic-class","text":"<p><code>@magicclass</code> decorator has several options.</p> <p>These options are inherited from <code>magicgui</code>:</p> <ul> <li><code>layout: str = \"vertical\"</code> ... Layout of container. <code>\"vertical\"</code> or <code>\"horizontal\"</code>.</li> <li><code>labels: bool = True</code> ... If <code>True</code>, parameter names will appear as labels.</li> <li><code>name: str = None</code> ... Name of widget. By default the class name is used.</li> </ul> <p>These options are <code>magicclass</code> specific:</p> <ul> <li><code>visible: bool = None</code> ... Initial visibility of the widget.</li> <li><code>close_on_run: bool = None</code> ... If <code>True</code> (default), <code>magicgui</code> widgets will be closed   after the function call.</li> <li> <p><code>popup: bool = True</code> ... Deprecated. Use <code>popup_mode</code> instead.</p> </li> <li> <p><code>popup_mode: str | PopUpMode = None</code> ... Specify how <code>magicgui</code> widgets are popped up.</p> <ul> <li><code>popup</code> (default): Popped up as a new window, like a dialog.</li> <li><code>first</code>: Appear on the first position of the container.</li> <li><code>last</code>: Appear on the last position of the container.</li> <li><code>below</code>: Appear below the button.</li> <li><code>above</code>: Appear above the button.</li> <li><code>parentlast</code>: Appear on the last position of the parent container.</li> <li><code>dock</code>: Appear as a dock widget. If the parent container is a dock widget of   <code>napari</code> viewer, then it is also added as a dock widget.</li> </ul> </li> <li> <p><code>error_mode: str | ErrorMode = None</code> ... Specify how exceptions in function call will be raised.</p> <ul> <li><code>msgbox</code>: Open a message box.</li> <li><code>stderr</code>: Print output as standard.</li> </ul> </li> <li> <p><code>widget_type: str | WidgetType = WidgetType.none</code> ... Specify widget types. See   all the available widget types.</p> </li> </ul> <p>To avoid writing the same options many times, you can change the default setting via <code>default</code> constant:</p> <pre><code>from magicclass import default\n\ndefault[\"close_on_run\"] = False\ndefault[\"popup_mode\"] = \"dock\"\n</code></pre>"},{"location":"basics/properties/","title":"Use magicproperty in magic-class","text":"<p>In <code>magicclass</code>, properties will not be conveted into widgets. The reason for this is that properties are usually used to get references to one of the child widgets. <pre><code>from magicclass import magicclass, field\n\n@magicclass\nclass A:\n    @magicclass\n    class B:\n        x = field(int)\n\n    @property\n    def bx(self):\n        return self.B.x\n</code></pre></p> <p>However, another property-like class <code>magicproperty</code> is available to build a <code>FunctionGui</code>-like widget.</p> <p>Note</p> <p><code>magicproperty</code> is a subclass of <code>MagicField</code>.</p>"},{"location":"basics/properties/#how-to-use-magicproperty","title":"How to Use <code>magicproperty</code>","text":"<p>Basically, it is used exactly the same as the built-in <code>property</code> class, except that you have to provide at least one type annotation for widget creation.</p> <pre><code>from magicclass import magicclass, magicproperty\n\n@magicclass\nclass A:\n    @magicproperty\n    def x(self) -&gt; int:\n        return self._x\n\n    @x.setter\n    def x(self, val: int):\n        self._x = val\n\n    @magicproperty\n    def string(self) -&gt; str:\n        return self._s\n\n    @string.setter\n    def string(self, val: str):\n        self._s = val\n\nui = A()\nui.show()\n</code></pre> <p></p> <p>Values are updated after the \"Set\" button is clicked, or set programmatically.</p> <pre><code>ui.x = 10  # update the value and the GUI\nui.string = \"Hello\"  # update the value and the GUI\n</code></pre>"},{"location":"basics/properties/#configuration-of-magicproperty","title":"Configuration of <code>magicproperty</code>","text":"<p><code>magicproperty</code> can be configured similar to <code>magicgui</code>. Here's some examples of how to configure.</p> <pre><code>@magicclass\nclass A:\n    # set widget label\n    @magicproperty(label=\"X\")\n    def x(self) -&gt; int:\n        ...\n\n    # widget type and options\n    @magicproperty(widget_type=\"Slider\", options={\"min\": 0, \"max\": 10})\n    def x(self) -&gt; int:\n        ...\n\n    # auto-calling\n    @magicproperty(auto_call=True)\n    def x(self) -&gt; int:\n        ...\n\n    # customize the button text\n    @magicproperty(call_button=\"update x value\")\n    def x(self) -&gt; int:\n        ...\n</code></pre>"},{"location":"basics/properties/#setter-only-property","title":"Setter-only property","text":"<p>Although it's rare, built-in <code>property</code> can be setter-only. In this case, you can only set a value and getting a value is forbidden.</p> <pre><code>class A:\n    x = property()\n\n    @x.setter\n    def x(self, val):\n        print(\"set x to\", val)\n\n    # python &gt;= 3.9\n    @property().setter\n    def x(self, val):\n        print(\"set x to\", val)\n\na = A()\na.x = 10  # OK\na.x  # AttributeError\n</code></pre> <p>Unlike <code>property</code>, however, the getter of <code>magicproperty</code> doesn't need to be defined because widget itself has its own value.</p> <pre><code>@magicclass\nclass A:\n    x = magicproperty(widget_type=\"Slider\")\n\n    @x.setter\n    def x(self, val: int):\n        print(\"set x to\", val)\n\n    # python &gt;= 3.9\n    @magicproperty(widget_type=\"Slider\").setter\n    def x(self, val: int):\n        print(\"set x to\", val)\n\na = A()\na.x = 10  # OK\na.x  # Out: 10\n</code></pre> <p>An advantage of setter-only <code>magicproperty</code> is that you don't have to prepare an additional attribute <code>_x</code> for the property <code>x</code>.</p> <p>Note</p> <p>You can even create a <code>magicproperty</code> without any descriptors.</p> <pre><code>@magicclass\nclass A:\n    x = magicproperty(annotation=int)\n    y = magicproperty(widget_type=\"RangeEdit\")\n</code></pre> <p>In this case, getter will get the value of the widget and setter will update the widget value.</p>"},{"location":"basics/serialize/","title":"Serialize/Deserialize GUI","text":"<p>It is useful in some cases to save the state of the GUI and restore it later. In most cases, widget states are defined by the widget values.</p> <p>In <code>magic-class</code>, simple <code>serialize</code> and <code>deserialize</code> functions are available. These methods can be used to save and load the state of the <code>magicgui</code>'s <code>Container</code> widgets or any magic-class widgets. All the value widgets or value-like widgets are recursively converted into dictionaries.</p> What is a value-like widget? <ol> <li><code>ValueWidget</code>, such as <code>SpinBox</code>, <code>Slider</code>, <code>CheckBox</code>, <code>ComboBox</code>, etc.</li> <li>Widget class that has a <code>value</code> property with both getter and setter being    defined. This includes <code>FileEdit</code> and custom magic-classes that have a proper    <code>value</code> property.</li> </ol>"},{"location":"basics/serialize/#basic-usage","title":"Basic Usage","text":"<p><code>serialize</code> and <code>deserialize</code> are available in the <code>magicclass.serialize</code> module. <code>serialize</code> converts the widget state to a dictionary, and <code>deserialize</code> does the opposite.</p> <p>Here's an example of serializing a <code>magicgui</code>'s <code>FunctionGui</code>.</p> <pre><code>from magicgui import magicgui\nfrom magicclass.serialize import serialize, deserialize\n\n@magicgui\ndef func(x: int = 1, y: str = \"X\"):\n    pass\n\nserialize(func)\n</code></pre> Output<pre><code>{'x': 1, 'y': 'X'}\n</code></pre> <p>And it can be deserialized back to the <code>FunctionGui</code> using <code>deserialize</code>.</p> <pre><code>deserialize(func, {\"x\": 2, \"y\": \"Y\"})\nprint(func)\n</code></pre> Output<pre><code>&lt;FunctionGui func(x: int = 2, y: str = 'Y')&gt;\n</code></pre> <p>Same functions can be used to serialize and deserialize magic-class widgets.</p> <pre><code>from magicclass import magicclass, field\n\n@magicclass\nclass Parameters:\n    x = field(1)\n    y = field(\"X\")\n\n    def print(self):\n        \"\"\"Print the parameters\"\"\"\n        print(\"x =\", self.x.value, \", y =\", self.y.value)\n\nparams = Parameters()\nserialize(params)\n</code></pre> Output<pre><code>{'x': 1, 'y': 'X'}\n</code></pre> <p>Note</p> <p>You may have noticed that a magic-class widget became very similar to a <code>pydantic</code> model.</p>"},{"location":"basics/serialize/#custom-serialization","title":"Custom Serialization","text":"<p>If a custom <code>Container</code> subclass or a magic-class widget need a special way for serialization and deserialization, you can define <code>__magicclass_serialize__</code> and <code>__magicclass_deserialize__</code> methods to do this.</p> <p>In the following example, widget values are saved as a tuple instead of separate dictionary items.</p> <pre><code>from magicclass import magicclass, field\n\n@magicclass\nclass A:\n    x = field(1)\n    y = field(\"X\")\n\n    def __magicclass_serialize__(self):\n        return {\"custom_value\": (self.x.value, self.y.value)}\n\n    def __magicclass_deserialize__(self, data):\n        self.x.value, self.y.value = data[\"custom_value\"]\n</code></pre> <p>Note</p> <p>You can use <code>serialize</code> in <code>__magicclass_serialize__</code> and <code>deserialize</code> in <code>__magicclass_deserialize__</code>, because these functions detects and avoids recursion.</p>"},{"location":"basics/serialize/#skip-serialization-for-some-values","title":"Skip Serialization for Some Values","text":"<p>Serialized data should be simple and usually JSON serializable. Some widgets may hold very complex data such as <code>numpy.ndarray</code> or <code>pandas.DataFrame</code>. In these cases, you may want to skip serialization for these values.</p> <p>The <code>skip_if</code> argument of <code>serialize</code> is designed for this purpose. It should be a callable that take a value and return <code>True</code> if the value should be skipped.</p> <pre><code># A widget that load an image from a path\nfrom pathlib import Path\nimport numpy as np\nfrom magicgui.widgets import Image\nfrom magicclass import magicclass, vfield\nfrom magicclass.serialize import serialize\n\n@magicclass\nclass A:\n    img = vfield(Image)\n    path = vfield(Path)\n\n    def load(self):\n        \"\"\"Load image from path\"\"\"\n        from skimage.io import imread\n\n        self.img = imread(self.path)\n\nui = A()\nui.path = \"path/to/image.png\"\nui.load()\nserialize(ui, skip_if=lambda x: isinstance(x, np.ndarray))\n</code></pre> Output<pre><code>{'path': WindowsPath('path/to/image.png')}\n</code></pre>"},{"location":"basics/tooltips/","title":"Set Tooltips","text":"<p>Adding tooltips is important for usability. If you are going to add all the tooltip naively, you will have to set <code>tooltip</code> property for every widget.</p> <pre><code>@magicclass\nclass A:\n    ...\n\nui = A()\nui[\"widget-1\"].tooltip = \"tooltip for widget-1\"\nui[\"widget-2\"].tooltip = \"tooltip for widget-2\"\n# ... and so on\n</code></pre> <p>However, this kind of documentation is not optimal. <code>magic-class</code> is designed to avoid GUI-specific lines to make code clean. This chapter shows how to provide tooltips in magic-classes in a tidy way.</p>"},{"location":"basics/tooltips/#add-tooltips-to-buttons-and-menus","title":"Add tooltips to buttons and menus","text":"<p>As explained in previous chapters, methods are converted into buttons in classes decorated with <code>@magicclass</code> and into menus when <code>@magicmenu</code> or <code>@magiccontext</code> are used. Following <code>magicgui</code> tooltip generation procedure, function docstrings are very useful for adding tooltips to the buttons and the widgets appear in the pop-up function GUI. In the example below:</p> <pre><code>from magicclass import magicclass\n\n@magicclass\nclass A:\n    def f(self, x: int):\n        \"\"\"\n        Description of the function.\n\n        Parameters\n        ----------\n        x : int\n            The first parameter.\n        \"\"\"\n</code></pre> <p>\"Description of the function.\" will be interpreted as a tooltip for button \"f\" and \"The first parameter.\" will be added as a tooltip to the <code>SpinBox</code> widget that will appear when the button \"f\" is clicked.</p> <p>A benefit of adding tooltips in this way is that you don't have to do more than documenting a Python code. What's more, these tooltips are compatible with auto- documentation using <code>sphinx</code> or <code>mkdocs</code>.</p>"},{"location":"basics/tooltips/#add-tooltips-to-classes","title":"Add tooltips to classes","text":"<p>When magic-classes are nested, you may want to add tooltips to child widgets. This time, class docstrings will be used for the purpose.</p> <pre><code>from magicclass import magicclass\n\n@magicclass\nclass A:\n    \"\"\"Description of A.\"\"\"\n\n    @magicclass\n    class B:\n        \"\"\"Description of B.\"\"\"\n</code></pre>"},{"location":"basics/tooltips/#add-tooltips-to-fields","title":"Add tooltips to fields","text":"<p>Another important component of magic-classes are fields. In a naive way, you'll have to set <code>\"tooltip\"</code> options for every field.</p> <pre><code>from magicclass import magicclass, vfield\n\n@magicclass\nclass A:\n    x = vfield(int, options={\"tooltip\": \"Description of what x is.\"})\n    y = vfield(str, options={\"tooltip\": \"Description of what y is.\"})\n</code></pre> <p>Again, this can also be substituted with docstrings of class itself.</p> <pre><code>from magicclass import magicclass, vfield\n\n@magicclass\nclass A:\n    \"\"\"\n    Description of this class.\n\n    Attributes\n    ----------\n    x : int\n        Description of what x is.\n    y : int\n        Description of what y is.\n    \"\"\"\n    x = vfield(int)\n    y = vfield(str)\n</code></pre> <p>Note that \"Attributes\" section is used here because fields are class attributes.</p>"},{"location":"make_better/","title":"Make Your GUI Better","text":"<p>It is important to make your GUI user friendly and intuitive.</p> <p><code>magic-class</code> provides many methods that can improve widget appearance and interactivity without disturbing readability and tidiness of the source code.</p> <ul> <li>Call Parent Methods from its Child</li> <li>Custom Keybindings</li> <li>Implement Undo/Redo</li> <li>Binding Values to Arguments</li> <li>Set Choices Dynamically</li> <li>Validation/Normalization for Macro Recording</li> <li>Complicated Settings of Dialogs</li> <li>Add Preview Functionality</li> <li>Pre-run Confirmation</li> <li>Multi-threading</li> <li>Set Custom Icons</li> <li>Logging in magic-class</li> <li>Additional types</li> <li>Container Variations</li> <li>Testing magic-class</li> </ul>"},{"location":"make_better/additional_types/","title":"Additional types","text":"<p>To make implementation simpler, <code>magic-class</code> has some additional types that were not available in <code>magicgui</code>.</p>"},{"location":"make_better/additional_types/#optional-type","title":"<code>Optional</code> type","text":"<p><code>Optional</code> type is almost identical to <code>typing.Optional</code>. Using this type annotation <code>@magicgui</code> can create an <code>OptionalWidget</code>, which has a checkbox and an widget of any type. It represents <code>None</code> if the checkbox is checked.</p> <pre><code>from magicgui import magicgui\nfrom magicclass.types import Optional\n\n@magicgui\ndef func(a: Optional[int]):\n    print(a)\nfunc\n</code></pre> <p></p> <p>The \"Use default value\" text can be changed by \"text\" option. Options of the inner widget (<code>SpinBox</code> in this example) can be set by \"options\" option.</p> <pre><code>from magicgui import magicgui\nfrom magicclass.types import Optional\n\n@magicgui(a={\"text\": \"Don't need a value\", \"options\": {\"min\": 1, \"max\": 10}})\ndef func(a: Optional[int]):\n    print(a)\nfunc\n</code></pre>"},{"location":"make_better/additional_types/#color-type","title":"<code>Color</code> type","text":"<p>There is no straightforward way to use a color as an input. In <code>magic-class</code> you can use <code>Color</code> type as a type annotation. This type is an alias of <code>Union[Iterable[float], str]</code> and is converted into <code>ColorEdit</code> widget. <code>ColorEdit</code> behaves very similar to the color editor in <code>napari</code>'s layer control.</p> <pre><code>from magicgui import magicgui\nfrom magicclass.types import Color\n\n@magicgui\ndef func(col: Color = \"red\"):\n    print(col)\nfunc\n</code></pre> <p></p>"},{"location":"make_better/additional_types/#path-type","title":"<code>Path</code> type","text":"<p><code>pathlib.Path</code> is a type supported by <code>magicgui</code> by default. However, you usually have to specify the <code>mode</code> and <code>filter</code> parameters.</p> <pre><code>from magicgui import magicgui\nfrom pathlib import Path\n\n@magicgui(path={\"mode\": \"w\", \"filter\": \"Image files (*.png)\"})\ndef func(path: Path):\n    print(path)\n</code></pre> <p>In <code>magicclass</code> you can use <code>magicclass.types.Path</code> type instead. It is identical to <code>pathlib.Path</code> when used as a constructor, but supports many other advanced annotations.</p> <pre><code>from magicclass.types import Path\n\n# mode=\"r\" and filter=\"Image files (*.png)\n@magicgui\ndef func1(path: Path.Read[\"Image files (*.png)\"]):\n    print(\"reading:\", path)\n\n# mode=\"w\" and filter=\"Image files (*.png)\n@magicgui\ndef func2(path: Path.Save[\"Image files (*.png)\"]):\n    print(\"saving at:\", path)\n\n# mode=\"rm\" and filter=\"Image files (*.png)\n@magicgui\ndef func3(path: Path.Multiple[\"Image files (*.png)\"]):\n    print(\"selected files:\", path)\n\n# mode=\"d\"\n@magicgui\ndef func4(path: Path.Dir):\n    print(\"selected directory =\", path)\n</code></pre>"},{"location":"make_better/additional_types/#exprstr-type","title":"<code>ExprStr</code> type","text":"<p><code>ExprStr</code> is a subtype of <code>str</code> that allows you to use a string as an expression. This type will be mapped to <code>EvalLineEdit</code>, which supports evaluation in any namespace.</p> <p>To activate auto-completion, you can use <code>ExprStr.In</code> for the type annotation. <code>ExprStr</code> instance has <code>eval</code> method to evaluate the expression.</p> <pre><code>import numpy as np\nfrom magicgui import magicgui\nfrom magicclass.types import ExprStr\n\nnamespace = {\"np\": np}\n\n@magicgui\ndef func(arr: ExprStr.In[namespace]):\n    print(ExprStr(arr, namespace).eval())\nfunc\n</code></pre>"},{"location":"make_better/bind/","title":"Binding Values to Arguments","text":"<p>In <code>magicgui</code>, you can bind values to function arguments instead of annotating them. The <code>\"bind\"</code> option is useful when the parameter is determined programatically, such as time, random value or parameters in other widgets.</p> <pre><code>from magicgui import magicgui\nimport time\n\ndef get_time(w):\n    return time.time()\n\n@magicgui(t={\"bind\": get_time})\ndef func(t):\n    print(t)\n</code></pre> <p>Same grammar also works in magic-class. Furthermore, there are more options here. Since many parameters will be obtained from widgets that are created by <code>field</code> function, or retrieved by some get-value instance methods, magic-class is desined in a way that also works with these options.</p>"},{"location":"make_better/bind/#use-methods","title":"Use Methods","text":"<p>If a method defined in a class is given as a bind option, magic-class calls it as an instance method every time the value is accessed. A bind option should be set using <code>set_options</code> wrapper as usual.</p> <pre><code>from magicclass import magicclass, set_options\nimport time\n\n@magicclass\nclass Main:\n    def __post_init__(self):\n        self.t_start = time.time()\n\n    def _get_time(self, w):\n        # To avoid being added as a widget, make this method private.\n        return time.time() - self.t_start\n\n    @set_options(t={\"bind\": _get_time})\n    def print_time(self, t):\n        print(t)\n</code></pre> <p>One of the advantages of this method is reproducibility of macro. In the example above, values to be returned by <code>_get_time</code> will differ a lot depending on whether you are manually calling function on GUI or executing as a Python script. When parameters are bound from methods, the returned values will be recorded as a macro so that results are always the same.</p> <pre><code>ui = Main()\nui.show()\n# click button once\nprint(ui.macro)\n</code></pre> Output:<pre><code>ui = Main()\nui.print_time(2.3758413791656494)\n</code></pre> <p>Tip</p> <p>The bind option is very useful to make macro-recordable napari plugin widgets. If a function need some information from the viewer, you can record the viewer's state.</p> <pre><code>@magicclass\nclass Plugin:\n    def _get_last_shapes(self, w):\n        viewer = self.parent_viewer\n        # ndarray will not be recorded as concrete values by default, to avoid recording very\n        # large arrays. You have to convert it to a list, or use \"register_type\" function in\n        # \"magicclass.macro\".\n        return viewer.layers[\"Shapes\"].data[-1].tolist()\n\n    @set_options(rectangle={\"bind\": _get_last_shapes})\n    def read_coordinates(self, rectangle):\n        ...\n</code></pre>"},{"location":"make_better/bind/#use-fields","title":"Use Fields","text":"<p>Many GUIs let users to set global parameters by widgets, and use these parameters in other functions. However, if you want to run the function from the script, you don't want to do this like:</p> <pre><code>ui.a.value = 1\nui.b.value = 2\nui.call()\n</code></pre> <p>Most programmers should prefer:</p> <pre><code>ui.call(1, 2)\n</code></pre> <p>An option to solve this problem is to define getter methods like <code>get_a_value</code> and <code>get_b_value</code> and bind them to the <code>call</code> method. But there is a way that is much simpler: bind field objects directly (See also field).</p> <pre><code>from magicclass import magicclass, set_options, field\n\n@magicclass\nclass Add:\n    a = field(float)\n    b = field(float)\n\n    @set_options(x0={\"bind\": a}, x1={\"bind\": b})\n    def call(self, x0, x1):\n        print(x0 + x1)\n</code></pre> <p>In this example, values <code>x0</code> and <code>x1</code> is determined by refering to <code>a.value</code> and <code>b.value</code>.</p>"},{"location":"make_better/bind/#use-annotated-type","title":"Use Annotated Type","text":"<p><code>magicgui</code> supports <code>Annotated</code> type, which makes GUI configurations much clearer.</p> <pre><code>from typing import Annotated\n# from typing_extensions import Annotated  &lt;--- for Python 3.8\n\n@magicgui\ndef func(i: Annotated[int, {\"max\": 10}]):\n    ...\n</code></pre> <p>In magic-class, you can also use <code>Annotated</code> for bind options.</p> <pre><code>from magicclass import magicclass, field\nfrom typing import Annotated\n\n@magicclass\nclass Add:\n    a = field(float)\n    b = field(float)\n\n    def call(\n        self,\n        x0: Annotated[float, {\"bind\": a}],\n        x1: Annotated[float, {\"bind\": b}],\n    ):\n        print(x0 + x1)\n</code></pre>"},{"location":"make_better/choices/","title":"Set Choices Dynamically","text":""},{"location":"make_better/choices/#choices-in-magicgui","title":"Choices in magicgui","text":"<p>Some <code>magicgui</code> widgets, such as <code>ComboBox</code> and <code>Select</code>, support <code>\"choices\"</code> option. This option not only accept static choices like <code>choices=[\"a\", \"b\", \"c\"]</code> but choices that can be dynamically changed are also supported by giving a choice-getter function.</p> <pre><code>from magicgui.widgets import ComboBox\nimport random\n\ndef _get_choices(widget=None):\n    # prepare choices randomly.\n    return random.choices([1, 2, 3, 4], k=2)\n\nwdt = ComboBox(choices=_get_choices)\n</code></pre> <p>In the example above, choices of the <code>ComboBox</code> widget are defined by the <code>_get_choices</code> function and will be resampled when <code>reset_choices</code> is called.</p> <p>If you want to create <code>FunctionGui</code> with dynamic choices, your code will look like this.</p> <pre><code>from magicgui import magicgui\n\n@magicgui(a={\"choices\": _get_choices})\ndef func(a):\n    \"\"\"do something\"\"\"\n</code></pre> <p>To resample choices, you only have to call the <code>reset_choices</code> method on the parent widget.</p> <pre><code>func.reset_choices()\n</code></pre>"},{"location":"make_better/choices/#use-methods","title":"Use Methods","text":"<p>Similar to the <code>\"bind\"</code> option, you can set method defined in a magic-class to <code>\"choices\"</code> option (See Binding Values to Arguments). Magic-class will call it as an instance method every time choices need resetting. A choices option should be set using <code>set_options</code> wrapper as usual.</p> <p>Following example is a simple file explorer made of <code>magicclass</code>. Since you have to reset choices every time current directory is changed, the <code>\"chocies\"</code> options is very important.</p> <pre><code>import os\nfrom magicclass import magicclass, set_options\n\nRETURN = \"../\"\n\n@magicclass\nclass Main:\n    def __init__(self):\n        self._cd = os.getcwd()  # get current directory\n\n    def _get_files(self, w=None):\n        return os.listdir(self._cd) + [RETURN]\n\n    @set_options(f={\"choices\": _get_files})\n    def set_directory(self, f: str):\n        if f == RETURN:\n            self._cd = os.path.dirname(self._cd)  # move back to the parent directory\n        else:\n            self._cd = os.path.join(self._cd, f)  # go to new directory\n        self.reset_choices()\n\n    def show_current_directory(self):\n        print(self._cd)\n</code></pre>"},{"location":"make_better/choices/#choices-in-magicfield","title":"Choices in MagicField","text":"<p>Unlike the <code>\"bind\"</code> option, <code>\"choices\"</code> option is sometimes useful in fields. Methods defined in a magic class can also be used in field objects.</p> <p>Following example is a file explorer similar to the previous one but defined using fields.</p> <pre><code>import os\nfrom magicclass import magicclass, set_options, field\nfrom magicgui.widgets import RadioButtons\n\nRETURN = \"../\"\n\n@magicclass\nclass Main:\n    def _get_files(self, w=None):\n        return os.listdir(self.cd.value) + [RETURN]\n\n    cd = field(os.getcwd(), enabled=False)\n    files = field(RadioButtons, options={\"choices\": _get_files})\n\n    def goto(self):\n        f = self.files.value\n        if f == RETURN:\n            self.cd.value = os.path.dirname(self.cd.value)  # move back to the parent directory\n        else:\n            self.cd.value = os.path.join(self.cd.value, f)  # go to new directory\n        self.reset_choices()\n</code></pre>"},{"location":"make_better/confirm/","title":"Pre-run Confirmation","text":"<p>Sometimes you want to confirm the input before running the function, especially when the function needs a long time to run or irreversibly changes the GUI state. The process of confirmation is usually GUI specific, as you'll not want a window to pop up when running the function from the script.</p>"},{"location":"make_better/confirm/#confirm-decorator","title":"<code>confirm</code> decorator","text":"<p><code>magic-class</code> provides a decorator to add confirmation process to a function.</p> <pre><code>from magicclass import magicclass, confirm\n\n@magicclass\nclass A:\n    @confirm(text=\"Are you sure to run this function?\")\n    def func(self):\n        ...\n</code></pre> <p>When you click the button, a confirmation window will pop up before running the function, but if you run the function from the script, the <code>@confirm</code> does nothing.</p>"},{"location":"make_better/confirm/#conditional-confirmation","title":"Conditional Confirmation","text":"<p>You can pass a condition to <code>@confirm</code> decorator. The confirmation window will pop up only when the condition is satisfied.</p> <pre><code>from magicclass import magicclass, confirm\n\n@magicclass\nclass A:\n    # use executable string as condition\n    @confirm(condition=\"ratio &lt; 0 or 1 &lt; ratio\", text=\"ratio out of range, continue?\")\n    def func(self, ratio: float):\n        ...\n</code></pre>"},{"location":"make_better/containers/","title":"Container Variations","text":""},{"location":"make_better/containers/#use-other-qt-widgets-as-container","title":"Use Other Qt Widgets as Container","text":"<p>In <code>magic-class</code>, many Qt widget variations are available in a same API as <code>magicgui</code>'s <code>Container</code>. You can use them by importing from <code>magicclass.widgets</code>:</p> <pre><code>from magicgui.widgets import LineEdit\nfrom magicclass.widgets import ScrollableContainer\n\n# A container with scroll area\nc = ScrollableContainer()\n\nfor i in range(10):\n    c.append(LineEdit())\nc.show()\n</code></pre>"},{"location":"make_better/containers/#available-containers","title":"Available Containers","text":"<p>Container variations are available in magic classes using <code>widget_type=...</code> keyword argument. For instance, you can create <code>ButtonContainer</code> by <code>@magicclass(widget_type=\"button\")</code>. Menu bar and tool bar will be added to appropriate spaces according to the container type.</p>"},{"location":"make_better/containers/#default-container","title":"Default Container","text":"<p>This is the most basic one. Same as <code>magicgui</code>'s <code>Container</code>.</p> <p></p> <ul> <li>option: <code>widget_type=\"none\"</code> (not needed)</li> </ul>"},{"location":"make_better/containers/#mainwindow","title":"MainWindow","text":"<p>Main window is used. Same as <code>magicgui</code>'s <code>MainWindow</code>. Toolbar is floatable in main window.</p> <p></p> <ul> <li>option: <code>widget_type=\"mainwindow\"</code></li> </ul>"},{"location":"make_better/containers/#buttoncontainer","title":"ButtonContainer","text":"<p>A push button widget is created. Contents of the container show up when the button is clicked.</p> <p></p> <ul> <li>option: <code>widget_type=\"button\"</code></li> <li>base Qt class: QPushButton</li> <li>additional properties</li> <li><code>text</code> ... Text of button.</li> </ul>"},{"location":"make_better/containers/#collapsiblecontainer","title":"CollapsibleContainer","text":"<p>Collapsible/expandable widget is created.</p> <p></p> <ul> <li>option: <code>widget_type=\"collapsible\"</code></li> <li>base Qt class: QToolButton</li> <li>additional properties</li> <li><code>text</code> ... Text of button.</li> <li><code>collapsed</code> ... Toggle visibility of the contents.</li> </ul>"},{"location":"make_better/containers/#draggablecontainer","title":"DraggableContainer","text":"<p>Container is packed in a scroll area. It can be scrolled by mouse drag.</p> <p></p> <ul> <li>option: <code>widget_type=\"draggable\"</code></li> <li>base Qt class: QScrollArea</li> <li>additional properties : None</li> </ul>"},{"location":"make_better/containers/#framecontainer","title":"FrameContainer","text":"<p>Container is enclosed by a line. It does not have its title unlike <code>GroupBoxContainer</code></p> <p></p> <ul> <li>option: <code>widget_type=\"frame\"</code></li> <li>base Qt class: QGroupBox</li> <li>additional properties: None</li> </ul>"},{"location":"make_better/containers/#groupboxcontainer","title":"GroupBoxContainer","text":"<p>Container is enclosed by a line. Widget name will be the title of the group box.</p> <p></p> <ul> <li>option: <code>widget_type=\"groupbox\"</code></li> <li>base Qt class: QGroupBox</li> <li>additional properties: None</li> </ul>"},{"location":"make_better/containers/#hcollapsiblecontainer","title":"HCollapsibleContainer","text":"<p>An horizontal collapsible/expandable widget is created.</p> <ul> <li>option: <code>widget_type=\"hcollapsible\"</code></li> <li>base Qt class: QToolButton</li> <li>additional properties</li> <li><code>collapsed</code> ... Toggle visibility of the contents.</li> </ul>"},{"location":"make_better/containers/#listcontainer","title":"ListContainer","text":"<p>Drag-and-drop is enabled for each contents of the container.</p> <p></p> <ul> <li>option: <code>widget_type=\"list\"</code></li> <li>base Qt class: QListWidget</li> <li>additional properties</li> <li><code>current_index</code> ... Index of currently selected widget.</li> </ul>"},{"location":"make_better/containers/#subwindowscontainer","title":"SubWindowsContainer","text":"<p>All the child widgets are displayed as subwindows in this container.</p> <p></p> <ul> <li>option: <code>widget_type=\"subwindows\"</code></li> <li>base Qt class: QMdiArea</li> <li>additional properties: None</li> </ul>"},{"location":"make_better/containers/#scrollablecontainer","title":"ScrollableContainer","text":"<p>Container is packed in a scroll area. It can be scrolled by scroll bars.</p> <p></p> <ul> <li>option: <code>widget_type=\"scrollable\"</code></li> <li>base Qt class: QScrollArea</li> <li>additional properties: None</li> </ul>"},{"location":"make_better/containers/#splittercontainer","title":"SplitterContainer","text":"<p>The borders between adjacent widgets are adjustable (every child widget is resizable). In the following image, splitter exists between the radio buttons and two push buttons.</p> <p></p> <ul> <li>option: <code>widget_type=\"split\"</code></li> <li>base Qt class: QSplitter</li> <li>additional properties: None.</li> </ul>"},{"location":"make_better/containers/#stackedcontainer","title":"StackedContainer","text":"<p>One child widget is visible at a time. Current index must be set programmatically or using other widgets.</p> <p></p> <ul> <li>option: <code>widget_type=\"stacked\"</code></li> <li>base Qt class: QStackedWidget</li> <li>additional properties</li> <li><code>current_index</code> ... Index of currently visible widget.</li> </ul>"},{"location":"make_better/containers/#tabbedcontainer","title":"TabbedContainer","text":"<p>Container widget composed of tabs and each widget is assigned to a tab. The name of each tab is determined according to the widget name of each child widget.</p> <p></p> <ul> <li>option: <code>widget_type=\"tabbed\"</code></li> <li>base Qt class: QTabWidget</li> <li>additional properties</li> <li><code>current_index</code> ... Index of currently active tab.</li> </ul>"},{"location":"make_better/containers/#toolboxcontainer","title":"ToolBoxContainer","text":"<p>Container widget composed of collapsible tool boxes and one box is expanded at a time. Each box has its own scroll area.</p> <p></p> <ul> <li>option: <code>widget_type=\"toolbox\"</code></li> <li>base Qt class: QToolBox</li> <li>additional properties</li> <li><code>current_index</code> ... Index of expanded child widget.</li> </ul>"},{"location":"make_better/containers/#type-map-of-containers","title":"Type Map of Containers","text":"WidgetType Container type <code>\"none\"</code> <code>Container</code> <code>\"button\"</code> <code>ButtonContainer</code> <code>\"collapsible\"</code> <code>CollapsibleContainer</code> <code>\"draggable\"</code> <code>DraggableContainer</code> <code>\"frame\"</code> <code>FrameContainer</code> <code>\"groupbox\"</code> <code>GroupBoxContainer</code> <code>\"list\"</code> <code>ListContainer</code> <code>\"mainwindow\"</code> <code>MainWindow</code> <code>\"scrollable\"</code> <code>ScrollableContainer</code> <code>\"split\"</code> <code>SplitterContainer</code> <code>\"stacked\"</code> <code>StackedContainer</code> <code>\"subwindows\"</code> <code>SubWindowsContainer</code> <code>\"tabbed\"</code> <code>TabbedContainer</code> <code>\"toolbox\"</code> <code>ToolBoxContainer</code>"},{"location":"make_better/icon/","title":"Set Custom Icons","text":"<p>An icon often tells more than a text. Using them in your GUI will be a good idea especially in a tool bar.</p> <p>Basically you'll set icons with the <code>icon</code> keyword argument of <code>@set_design</code> decorator. There are several ways to do that in <code>magic-class</code>.</p>"},{"location":"make_better/icon/#image-file-as-an-icon","title":"Image File as an Icon","text":"<p>If you have your icon file in such as .jpg or .svg format, you can use the path.</p> <pre><code>from magicclass import magicclass, magictoolbar, set_design\n\nicon_path = \"path/to/icon.png\"\n\n@magicclass\nclass A:\n    @magictoolbar\n    class toolbar:\n        @set_design(icon=icon_path)\n        def func(self):\n            ...\n</code></pre>"},{"location":"make_better/icon/#array-as-an-icon","title":"Array as an Icon","text":"<p>You may want to apply some transformation to an icon image. In this case, an array-like object can be used.</p> <pre><code>from magicclass import magicclass, magictoolbar, set_design\nfrom skimage import io\n\nimg = io.imread(\"path/to/image.png\")  # read image as a np.ndarray\nicon = -img  # invert image\n\n@magicclass\nclass A:\n    @magictoolbar\n    class toolbar:\n        @set_design(icon=icon)\n        def func(self):\n            ...\n</code></pre>"},{"location":"make_better/icon/#iconify-icons","title":"Iconify icons","text":"<p>As <code>magicgui</code> also supports it, you can use <code>iconify</code> to convert a string to an icon.</p> <ul> <li>pyconify</li> <li>iconify</li> </ul> <pre><code>from magicclass import magicclass, magictoolbar, set_design\n\n@magicclass\nclass A:\n    @magictoolbar\n    class toolbar:\n        @set_design(icon=\"mdi:bell\")  # &lt;-- string to icon\n        def func(self):\n            ...\n</code></pre>"},{"location":"make_better/keybinding/","title":"Custom Keybindings","text":"<p>Keybindings are very useful in many situations, especially when some functions will be called many times. In most cases, you will have to set shortcuts to a push button or an action in the menu so that bound function will be accessible via GUI.</p> <p>Magic class provides a wrapper function which makes it easy to implement custom keybindings, and like other wrappers, you don\\'t have to worry about reducing code readability.</p>"},{"location":"make_better/keybinding/#how-to-define-keybindings","title":"How to Define Keybindings","text":"<p>All you have to do is to wrap methods with <code>bind_key</code> function.</p> <pre><code>from magicclass import magicclass, bind_key\n\n@magicclass\nclass Main:\n    @bind_key(\"Ctrl+A\") # Qt-style\n    def function_1(self):\n        print(1)\n\n    @bind_key(\"Ctrl-B\") # napari-style\n    def function_2(self):\n        print(2)\n</code></pre> <p>Note</p> <p>If you are going to use magic class as a dock widget in <code>napari</code>, make sure there is no collision between your keybindings and those in <code>napari</code>.</p>"},{"location":"make_better/keybinding/#decorate-private-functions","title":"Decorate Private Functions","text":"<p>Although private functions (functions whose names start with \"_\") will not be converted into widgets, it is very useful to define \"invisible\" shortcuts. A typical case is when you want to change widget values with shortcut.</p> <pre><code>from magicclass import magicclass, field, bind_key, do_not_record\n\n@magicclass\nclass Main:\n    a = field(int)\n    def button(self):\n        \"\"\"Click this button to remove focus from the spin box.\"\"\"\n\n    @bind_key(\"Up\")\n    def _increment(self):\n        self.a.value = min(self.a.value + 1, self.a.max)\n\n    @bind_key(\"Down\")\n    def _decrement(self):\n        self.a.value = max(self.a.value - 1, self.a.min)\n</code></pre> <p>Widget defined by this class is equipped with shortcuts that can change the value of <code>a</code> without clicking the spin box.</p>"},{"location":"make_better/keybinding/#key-combos","title":"Key combos","text":"<p>As Qt supports it, you can also define key combos.</p> <pre><code>from magicclass import magicclass, bind_key\n\n@magicclass\nclass Main:\n    @bind_key(\"Ctrl+K, Ctrl+L\")\n    def function_1(self):\n        print(1)\n</code></pre>"},{"location":"make_better/keybinding/#compatibility-with-other-features","title":"Compatibility with Other Features","text":"<p>Keybindings are compatible with other functions in magic class.</p> <p>You can call parent methods by combining with <code>wraps</code> method (see <code>/main/make_better/use_wraps</code>).</p> <pre><code>from magicclass import magicclass, magicmenu, bind_key\n\n@magicclass\nclass Main:\n    @magicmenu\n    class Menu:\n        def some_function(self): ...\n\n    @Menu.wraps\n    @bind_key(\"Ctrl+A\")\n    def some_function(self):\n        print(self.__class__.__name__) # should be \"Main\"\n</code></pre> <p>In this example, shortcut description appears in the menu.</p> <p></p> <p>You can also bind values of fields or other methods (see how to bind values).</p> <pre><code>from magicclass import magicclass, bind_key, field\nfrom typing import Annotated\n\n@magicclass\nclass Main:\n    a = field(int)\n    @bind_key(\"Ctrl-A\")\n    def print_value(self, a: Annotated[int {\"bind\": a}]):\n        print(a)\n</code></pre> <p>Function calls triggered by shortcut are also recorded in macro.</p>"},{"location":"make_better/location/","title":"Call Parent Methods from its Child","text":"<p>When you want to define a function under the parent class while put its push button or action in the child widget for better widget design, code will look very complicated and will be hard to maintain. This problem usually happens when you want a menu bar, since menu actions always execute something using the parameters of the parent and often update its parent.</p> <p>You can use the <code>location=...</code> argument of <code>@set_design</code> decorator to put buttons in other locations.</p>"},{"location":"make_better/location/#basic-syntax","title":"Basic Syntax","text":"<p>You have to do is:</p> <ol> <li>Define child class</li> <li>Define parent method</li> <li>Define a child method with the same name as that of parent's (not necessary but    recommended)</li> <li>Call <code>@set_design(location=ParentClass)</code></li> </ol> <p>Following example shows how to call <code>set_param</code> and <code>print_param</code> functions from its child class <code>Child</code>.</p> <pre><code>from magicclass import magicclass, field, set_design\n\n@magicclass\nclass Parent:\n    param = 0.1\n\n    @magicclass(layout=\"horizontal\")\n    class Child:\n        # A frame of buttons\n        def set_param(self): ...\n        def print_param(self): ...\n\n    # a result widget\n    result = field(widget_type=\"LineEdit\", options={\"enabled\": False})\n\n    @set_design(location=Child)\n    def set_param(self, value: float):\n        self.param = value\n\n    @set_design(location=Child)\n    def print_param(self):\n        self.result.value = self.param\n\nui = Parent()\nui.show()\n</code></pre> <p></p> <p>The <code>Parent</code> methods will not appear in the parent widget because they already exist in the child widget.</p> why pre-definition? <p>Method pre-definition in Step 3. is not a must. It is recommended, however, in several reasons:</p> <ol> <li>It plays as an \"index\" of functions. One can know what functions are implemented    in the GUI, and in what order they will appear in widgets.</li> <li>If the widget is composed of nested magic classes and other widgets or fields,    the order of widgets will not be sorted due to different timing of widget    creation.</li> </ol>"},{"location":"make_better/location/#use-abstractapi-decorator","title":"Use <code>@abstractapi</code> decorator","text":"<p>Method pre-definition cannot be statically checked by IDEs; if you mistakenly re-defined a method with misspelled name, or you forgot to re-define a method, the GUI will have an button that does nothing with no warning nor error.</p> <pre><code>@magicclass\nclass Parent:\n    @magicclass\n    class Child:\n        def run_fucntion(self): ...  # &lt;------ misspelled!!\n\n    @set_design(location=Child)\n    def run_function(self, value: float):\n        \"\"\"Do something\"\"\"\n\nui = Parent()\nui.show()\n</code></pre> <p>To avoid this, you can use <code>abstractapi</code> class to define abstract methods. Abstract API will be resolve only if the function is re-defined in the parent widget or overriden by such as its subclass.</p> <pre><code>@magicclass\nclass Parent:\n    @magicclass\n    class Child:\n        run_fucntion = abstractapi()  # &lt;------ misspelled!!\n\n    @set_design(location=Child)\n    def run_function(self, value: float):\n        \"\"\"Do something\"\"\"\n\nui = Parent()  # AbstracAPIError will be raised here\n</code></pre> <p><code>abstractapi</code> is not necessarily used as a decorator. It can be instantiated as if a field object.</p> <pre><code>@magicclass\nclass Parent:\n    @magicclass\n    class Child:\n        run_fucntion = abstractapi()  # &lt;------ like this\n</code></pre>"},{"location":"make_better/location/#find-ancestor-widgets","title":"Find Ancestor Widgets","text":"<p>If your purpose is just to get the ancestor widget, you can use <code>find_ancestor</code> method instead. <code>self.find_ancestor(X)</code> will iteratively search for the widget parent until it reaches an instance of <code>X</code>.</p> <pre><code>@magicclass\nclass Main:\n    @magicclass\n    class A:\n        def func(self):\n            ancestor = self.find_ancestor(Main)\n            # do something on the ancestor widget\n</code></pre> <p>In terms of calling parent methods, <code>find_ancestor</code> works very similar to what you do with <code>@set_design(location=ParentClass)</code>. However, there are some cases where using <code>find_ancestor</code> is better.</p> <ul> <li> <p>You can define child widget class outside the parent widget class (even in a   separate file).</p> child.py<pre><code>from magicclass import magicmenu\n\n@magicmenu\nclass A:\n    def func(self):\n        ancestor = self.find_ancestor(Main)\n        # do something on the ancestor widget\n</code></pre> main.py<pre><code>from magicclass import magicclass\nfrom .child import A\n\n@magicclass\nclass Main:\n    A = A\n</code></pre> </li> <li> <p>Recorded macro will be different. In the case of calling <code>find_ancestor</code>, macro will   be recorded as <code>\"ui.ChildClass.method(...)\"</code> while it will be <code>\"ui.method(...)\"</code> if   you used <code>@wraps</code>. In terms of readability, usually <code>@wraps</code> will be better.</p> </li> </ul> <p>Note</p> <p>If parent widget will not change, you can cache the parent widget by <code>self.find_ancestor(Main, cache=True)</code>. This is faster so is useful if the function will be repeatitively called.</p>"},{"location":"make_better/location/#field-locations","title":"Field Locations","text":"<p>Same strategy can be used for fields.</p> <pre><code>from magicclass import magicclass, field, abstractapi\n\n@magicclass\nclass A:\n    @magicclass(layout=\"horizontal\")\n    class Parameters:\n        a = abstractapi()\n        b = abstractapi()\n\n    a = field(int, location=Parameters)\n    b = field(int, location=Parameters)\n    def add(self):\n        print(self.a.value + self.b.value)\n\nui = A()\nui.show()\n</code></pre> <p></p>"},{"location":"make_better/logging/","title":"Logger Widget","text":"<p>It is important to keep a log if your GUI is complicated. In data science, it is also helpful to show the results with rich text, tables, and figures.</p> <p>In <code>magicclass</code>, you can use the logger widget to show the rich messages.</p> <pre><code>from magicclass.widgets import Logger\n\nlog = Logger()  # create a logger widget.\nlog.show()  # show the logger widget.\n</code></pre>"},{"location":"make_better/logging/#print-texts","title":"Print texts","text":"<p>There are several ways to show text messages.</p> <pre><code>from magicclass.widgets import Logger\n\nlog = Logger()  # create a logger widget.\n\nlog.print(\"message\")  # print the message.\nlog.print_html(\"&lt;b&gt;bold&lt;/b&gt;&lt;i&gt;italic&lt;/i&gt; &lt;code&gt;code&lt;/code&gt;\")  # print the message with HTML.\nlog.print_rst(\"**bold** *italic* ``code``\")  # print the message with reStructuredText.\nlog\n</code></pre> <p></p> <p>If you want to use the built-in <code>print</code> function but show the message in the logger widget, you can use the <code>set_stdout</code> context manager.</p> <pre><code>with log.set_stdout():\n    print(\"message\")  # print the message.\n</code></pre> <p><code>set_logger</code> context manager works similarly.</p> <pre><code>import logging\n\nwith log.set_logger():\n    logging.info(\"message\")\n</code></pre>"},{"location":"make_better/logging/#print-images","title":"Print images","text":"<p>You can show 2D arrays as images with <code>print_image</code> method.</p> <pre><code>log.print_image(np.random.rand(100, 100))  # show the image.\n</code></pre>"},{"location":"make_better/logging/#print-tables","title":"Print tables","text":"<p>Any <code>pandas.DataFrame</code>-like objects can be shown as a table with <code>print_table</code> method.</p> <pre><code>log = Logger()\nlog.print_table({\"a\": [1, 2, 3], \"b\": [True, False, False]})\nlog.print_table([[0, 1], [2, 3]])\nlog\n</code></pre> <p></p>"},{"location":"make_better/logging/#plotting","title":"Plotting","text":"<p>The <code>set_plt</code> context manager can be used to show the <code>matplotlib</code> plots in the logger widget.</p> <pre><code>import matplotlib.pyplot as plt\n\nlog = Logger()\n\nwith log.set_plt():\n    plt.plot([1, 2, 3], [4, 5, 6])\n    plt.show()\nlog\n</code></pre> <p></p>"},{"location":"make_better/logging/#use-logging-submodule","title":"Use <code>logging</code> Submodule","text":"<p><code>magicclass</code> provides a submodule <code>logging</code> to use the logger widget easily. Most of the methods are the same as the standard <code>logging</code> module.</p> <pre><code>from magicclass import logging\n\nlogger = logging.getLogger(\"your-app-name\")\nlogger.widget.show()  # show the logger widget.\n\nlogger.print(\"message\")  # print the message.\nwith logger.set_plt():\n    plt.plot([1, 2, 3], [4, 5, 6])  # plot\n</code></pre>"},{"location":"make_better/preview/","title":"Add Preview Functionalities","text":"<p>It is a very usual case when you want to preview something before actually running a function.</p> <ol> <li>Suppose in your GUI you implemented a function that can load a csv file and    summarize its contents, you may want to open the csv file and see if you chose the correct file.</li> <li>Suppose you want to process a dataset in-place, you may want to add a \"preview\"    checkbox so that you can search for the proper parameters (imagine Gaussian filter    function in other softwares).</li> </ol> <p>The preview functionality is, however, unexpectedly hard to be implemented in <code>magicgui</code> or <code>magic-class</code>.</p> <ul> <li>If they are implemented in separate buttons, say in button \"summarize csv\" and   \"preview csv\", users have to synchronize all the input arguments between these two   widgets.</li> <li>If they are implemented in a same widget, you have to add an additional button in the   bottom of the <code>FunctionGui</code>. This is not simple and hard to maintain.</li> <li>In the case of 2, you'll have to properly connect signals such as \"turn on preview\",   \"turn off preview\" and \"restore the original state\", which is not an easy task.</li> </ul> <p>In <code>magic-class</code>, <code>impl_preview</code> decorator is very useful for this purpose. You can define a preview function and directly integrate it into another function easily.</p>"},{"location":"make_better/preview/#preview-a-file","title":"Preview a File","text":"<pre><code>@impl_preview(f)\ndef _f_prev(self, xxx):\n    ...\n</code></pre> <p>will define a previewer <code>_f_prev</code> for function <code>f</code>. Arguments of <code>_f_prev</code> must be composed of those in <code>f</code>. The <code>_f_prev</code> can be called from the <code>FunctionGui</code> created by <code>f</code>, as a preview button above the call button.</p> <pre><code>from pathlib import Path\nimport pandas as pd\nfrom magicgui.widgets import Table  # for preview\nfrom magicclass import magicclass, impl_preview\n\n@magicclass\nclass A:\n    def summarize_csv(self, path: Path):\n        df = pd.read_csv(path)\n        print(df.agg([np.mean, np.std]))  # print summary\n\n    @impl_preview(summarize_csv)\n    def _preview_csv(self, path):\n        df = pd.read_csv(path)\n        Table(value=df).show()  # open table widget as the preview\n</code></pre> <p>Previewer don't have to accept all the arguments. Suppose you defined a function <code>calc_something</code> that calculate something using a data frame and a input parameter like <code>calc_something(df, param)</code>, the <code>param</code> in not needed for preview.</p> <pre><code>@magicclass\nclass A:\n    def calc_csv(self, path: Path, param: float):\n        df = pd.read_csv(path)\n        result = calc_something(df, param)\n        print(result)\n\n    @impl_preview(calc_csv)\n    def _preview_csv(self, path):  # \"param\" is not needed here\n        df = pd.read_csv(path)\n        Table(value=df).show()\n</code></pre> <p>You can mark the same function as a previewer for multiple functions. You can also set the text of preview button using <code>text=...</code> argument.</p> <pre><code>@magicclass\nclass A:\n    def summarize_csv(self, path: Path):\n        df = pd.read_csv(path)\n        print(df.agg([np.mean, np.std]))\n\n    def calc_csv(self, path: Path, param: float):\n        df = pd.read_csv(path)\n        result = calc_something(df, param)\n        print(result)\n\n    def plot_csv(self, path: Path):\n        df = pd.read_csv(path)\n        df.plot()\n\n    @impl_preview(summarize_csv)\n    @impl_preview(calc_csv)\n    @impl_preview(plot_csv, text=\"preview CSV\")\n    def _preview_csv(self, path):  # \"param\" is not needed here\n        df = pd.read_csv(path)\n        Table(value=df).show()\n</code></pre>"},{"location":"make_better/preview/#prerun-a-function","title":"Prerun a Function","text":"<p>This is essentially same as 1, except that the preview function will update some parts of the GUI. Following example shows an incomplete implementation of a previewable Gaussian filtering.</p> <pre><code>from magicclass import magicclass, impl_preview, vfield\nfrom magicgui.widgets import Image\nfrom scipy import ndimage as ndi\n\n@magicclass\nclass A:\n    img = vfield(Image)\n\n    def __post_init__(self):\n        # sample image\n        self.img = np.random.random((100, 100))\n        self[\"img\"].min_width = 100\n        self[\"img\"].min_height = 100\n\n    def gaussian_filter(self, sigma: float = 1.0):\n        \"\"\"Run Gaussian filter inplace\"\"\"\n        self.img = ndi.gaussian_filter(self.img, sigma)\n\n    @impl_preview(gaussian_filter)\n    def _prerun(self, sigma):\n        self.gaussian_filter(sigma)\n\nui = A()\nui.show()\n</code></pre> <p>The problem here is that the preview function <code>_prerun</code> updates the GUI state so the second preview and the actual run are affected by the previous previews.</p> <p>To restore the original GUI state, you can use a generator function.</p> <pre><code>@magicclass\nclass A:\n    ...\n\n    @impl_preview(gaussian_filter)\n    def _prerun(self, sigma):\n        old = self.img  # store current image\n        self.gaussian_filter(sigma)  # run preview\n        yield  # prerun called here\n        self.img = old  # restore\n</code></pre> <p>Note</p> <p><code>impl_preview</code> does NOT check if the preview function actually restored the GUI state. The logic of the preview function is up to you.</p>"},{"location":"make_better/preview/#auto-call","title":"Auto call","text":"<p>In the example above, it's nicer to auto-call the preview function. <code>impl_preview</code> has an option <code>auto_call=True</code> to implement this.</p> <pre><code>@magicclass\nclass A:\n    ...\n\n    @impl_preview(gaussian_filter, auto_call=True)\n    def _prerun(self, sigma):\n        old = self.img  # store current image\n        self.gaussian_filter(sigma)  # run preview\n        yield  # prerun called here\n        self.img = old  # restore\n</code></pre> <p>In the auto-call mode, a checkbox (instead of an additional button) will be added to the dialog. Preview will be auto-called if the checkbox in checked.</p>"},{"location":"make_better/setup/","title":"Complicated Settings of Dialogs","text":"<p>GUIs built by <code>@magicgui</code> can be customized later.</p> <pre><code>from magicgui import magicgui\n\n@magicgui\ndef func(x: int, y: int):\n    return x + y\n\n# connect signals\n@func.x.changed.connect\ndef _(val):\n    func.y.value = val\n\n# add widgets\nfunc.append(...)\n</code></pre> <p>Of course, you can do this customization by calling <code>get_function_gui</code> inside <code>__post_init__</code>.</p> <pre><code>from magicclass import magicclass, get_function_gui\n\n@magicclass\nclass A:\n    def __post_init__(self):\n        gui = get_function_gui(self.func)\n        gui.x.changed.connect(print)  # setup the dialog for `func`\n\n    def func(self, x: int):\n        \"\"\"Do something\"\"\"\n</code></pre> <p>But the better solution is to use <code>@setup_function_gui</code> decorator.</p> <pre><code>from magicclass import magicclass, setup_function_gui\n\n@magicclass\nclass A:\n    def func(self, x: int):\n        print(x)\n\n    @setup_function_gui(func)\n    def _setup_func(self, mgui):\n        mgui.x.changed.connect(print)\n</code></pre> <p>This can be done outside the class.</p> <pre><code>from magicclass import magicclass, setup_function_gui\n\n@magicclass\nclass A:\n    def func(self, x: int):\n        print(x)\n\n@setup_function_gui(A.func)\ndef _setup_func(self, mgui):\n    mgui.x.changed.connect(print)\n</code></pre>"},{"location":"make_better/testing/","title":"Testing Magic classes","text":"<p><code>magicclass.testing</code> contains several functions to test the magic classes.</p>"},{"location":"make_better/testing/#testing-function-gui-creation","title":"Testing Function GUI Creation","text":"<p>All the <code>FunctionGui</code> s are built lazily, that is, they are built only after user clicked the corresponding button. Therefore, the building error cannot be detected in the \"compile\" time.</p> <p>To test if all the <code>FunctionGui</code>s can be built successfully, you can use <code>check_function_gui_buildable</code>.</p> <pre><code>from magicclass import magicclass\nfrom magicclass.testing import check_function_gui_buildable\n\n@magicclass\nclass MyGui:\n    def f(self, x):  # x is not annotated, so @magicgui will fail\n        ...          # to build a functional GUI.\n\nui = MyGui()\n\ncheck_function_gui_buildable(ui)  # this will raise an error on \"f\"\n</code></pre> <p><code>check_function_gui_buildable</code> can also detect inappropriate bind options choices.</p>"},{"location":"make_better/testing/#testing-docstrings","title":"Testing Docstrings","text":"<p>Magic classes can use the python docstring (<code>__doc__</code>) to generate the tooltips of the corresponding widgets. However, when you renamed some of the variables, IDE may not rename the docstrings automatically. This will cause the tooltips not matching the actual variables.</p> <p>To test if all the docstrings are correct, you can use <code>check_tooltip</code>.</p> <pre><code>from magicclass import magicclass\nfrom magicclass.testing import check_tooltip\n\n@magicclass\nclass MyGui:\n    def f(self, x: int):\n        \"\"\"\n        ......\n\n        Parameters\n        ----------\n        y : int         # &lt;---- this should be \"x\"\n            ......\n        \"\"\"\n\nui = MyGui()\n\ncheck_tooltip(ui)  # wrong \"y\" will be reported\n</code></pre>"},{"location":"make_better/testing/#testing-preview-and-confirmation","title":"Testing Preview and Confirmation","text":"<p><code>magic-class</code> natively supports method preview and confirmation. These are again a runtime feature, so they is hard to be tested.</p> <p><code>FunctionGuiTester</code> is the class for this purpose.</p> <pre><code>from magicclass import magicclass, confirm, impl_preview, vfield\nfrom magicclass.testing import FunctionGuiTester\n\n@magicclass\nclass MyGui:\n    # confirm before run if x is too large\n    @confirm(condition=\"x&gt;100\")\n    def f(self, x: int):\n        for i in range(x):\n            print(i)\n\n    # method g has a preview function \"_g_preview\"\n    def g(self, x: int):\n        self.result = str(x ** 2)\n\n    @impl_preview(g)\n    def _g_preview(self, x: int):\n        old = self.result\n        self.g(x)  # prerun\n        yield\n        self.result = old  # cleanup\n\n    result = vfield(str)  # show the result of \"g\"\n\nui = MyGui()\ntester = FunctionGuiTester(ui.f)  # create a tester for function \"f\"\n</code></pre> <p><code>FunctionGuiTester.call</code> will call the method as if it is called from GUI, but it will not open the default confirmation dialog (otherwise your test session will wait for your response). The confirmation callback is temporarily replaced by a dummy function. You can check if the confirmation is called using the <code>confirm_count</code> attribute.</p> <pre><code># test if the confirmation works\ntester.call(x=200)\nassert tester.confirm_count == 1\n</code></pre> <p>To test preview function, you can use <code>FunctionGuiTester.update_parameters</code> to update the GUI state and <code>FunctionGuiTester.click_preview</code> to trigger the preview function.</p> <pre><code>tester = FunctionGuiTester(ui.g)  # create a tester for function \"g\"\n\n# test if the confirmation works\ntester.update_parameters(x=5)\nassert ui.result == \"\"  # check preview is not called yet\ntester.click_preview()\nassert ui.result == \"25\"  # check preview is working\n</code></pre>"},{"location":"make_better/undo/","title":"Implement Undo/Redo","text":"<p>Undo is important for the user to be able to correct mistakes, but it is extremely difficult to implement. There are several undo/redo architectures. In <code>magic-class</code>, an undoable method is defined by a forward function and a reverse function. When a forward function converts GUI state from A to B, then the reverse function should do the opposite (B to A).</p> <p>The undo/redo operations can be executed from the macro instance using <code>ui.macro.undo</code> and <code>ui.macro.redo</code>.</p>"},{"location":"make_better/undo/#basic-syntax","title":"Basic Syntax","text":"<p><code>magicclass.undo.undo_callback</code> is a decorator that converts a function into a callback that can be recognized by magic-classes. Returned callback will be properly processed so that the GUI operations can be recorded in the undo stack.</p> <p>Note</p> <p>You don't have to define the redo function. The redo action can be automatically defined using the GUI macro strings.</p>"},{"location":"make_better/undo/#standard-methods","title":"Standard methods","text":"<p>For standard methods, just return the undo callback.</p> <pre><code>from magicclass import magicclass\nfrom magicclass.undo import undo_callback\n\n@magicclass\nclass A:\n    ...\n\n    def func(self, ...):\n        ########################\n        #   forward function   #\n        ########################\n        @undo_callback\n        def undo():\n            ########################\n            #   reverse function   #\n            ########################\n        return undo\n</code></pre> <p>Note</p> <p>The reason why we need to define the reverse function inside the forward function is that the reverse function usually needs the local variables of the forward function to return the GUI state to the original.</p> <p>An example of undoable setter method is like this:</p> <pre><code>from magicclass import magicclass\nfrom magicclass.undo import undo_callback\n\n@magicclass\nclass A:\n    def __init__(self):\n        self._x = 0\n\n    def set_x(self, x: int):\n        old_state = x\n        self._x = x\n        @undo_callback\n        def undo():\n            self._x = old_state\n        return undo\n</code></pre>"},{"location":"make_better/undo/#thread-workers","title":"Thread workers","text":"<p>When you use multi-threading, you'll usually return returned-callbacks, which seems to collide with the undo callback. In this case, you can return an undo callback from the returned-callback.</p> <pre><code>from magicclass.utils import thread_worker\n\n@magicclass\nclass A:\n    @thread_worker\n    def long_running_function(self, ...):\n        ########################\n        #   forward function   #\n        ########################\n\n        @undo_callback\n        def undo():\n            ########################\n            #   reverse function   #\n            ########################\n\n        @thread_worker.callback\n        def out():\n            ########################\n            #   returned-callback  #\n            ########################\n            return undo\n        return out\n</code></pre>"},{"location":"make_better/undo/#the-undo-stack","title":"The Undo Stack","text":"<p>Executed undoable operations are all stored in the \"undo stack\". Suppose you've defined two undoable methods <code>f</code>, <code>g</code> and a non-undoable method <code>not_undoable</code> in magic class <code>A</code>, the undo stack will change as follow.</p> <pre><code>                    # Undo list / redo list\nui = A()            # [], []\nui.f(x=0)           # [&lt;ui.f(x=0)&gt;], []\nui.g(y=1)           # [&lt;ui.f(x=0)&gt;, &lt;ui.g(y=1)&gt;], []\nui.macro.undo()     # [&lt;ui.f(x=0)&gt;], [&lt;ui.g(y=1)&gt;]\nui.macro.undo()     # [], [&lt;ui.f(x=0)&gt;, &lt;ui.g(y=1)&gt;]\nui.macro.undo()     # [], [&lt;ui.f(x=0)&gt;, &lt;ui.g(y=1)&gt;] (excessive undo does nothing)\nui.macro.redo()     # [&lt;ui.f(x=0)&gt;], [&lt;ui.g(y=1)&gt;]\nui.macro.redo()     # [&lt;ui.f(x=0)&gt;, &lt;ui.g(y=1)&gt;], []\nui.macro.redo()     # [&lt;ui.f(x=0)&gt;, &lt;ui.g(y=1)&gt;], [] (excessive redo does nothing)\nui.not_undoable()   # [], [] (non-undoable function call clears the undo stack)\n</code></pre> <p>Since undo operation is tightly connected to the macro, non-recordable methods will not added to undo stack, nor will they clear the undo stack when get called.</p> <pre><code>@magicclass\nclass A:\n    @do_not_record\n    def non_recordable(self): ...\n\n    def undoable(self):\n        @undo_callback\n        def out():\n            ...\n        return out\n                     # Undo list / redo list\nui = A()             # [], []\nui.undoable()        # [&lt;ui.undoable()&gt;], []\nui.undoable()        # [&lt;ui.undoable()&gt;] * 2, []\nui.non_recordable()  # [&lt;ui.undoable()&gt;] * 2, []\nui.undoable()        # [&lt;ui.undoable()&gt;] * 3, []\n</code></pre>"},{"location":"make_better/undo/#custom-redo-action","title":"Custom Redo Action","text":"<p>Redo action is defined by the GUI macro string. However, you can also define it by yourself. It is useful when the forward function is a long-running task.</p> <p>Following GUI can calculate the <code>_very_heavy_task</code> with the given <code>x</code> and show the result in the <code>self.result</code> widget.</p> <pre><code>from magicclass import magicclass, vfield\nfrom magicclass.undo import undo_callback\n\n@magicclass\nclass A:\n    result = vfield(int)\n\n    def func(self, x: int):\n        old_result = self.result\n        result = self._very_heavy_task(x)\n        self.result = result\n\n        @undo_callback\n        def out():\n            self.result = old_result  # undo\n\n        return out\n</code></pre> <p>Although the undo/redo operations are well-defined, it takes a long time again to redo.</p> <pre><code>ui = A()\nui.func(1)  # long-running task\nui.macro.undo()  # very fast\nui.macro.redo()  # long-running task again!!\n</code></pre> <p>Function decorated by <code>magicclass.undo.undo_callback</code> has an attribute <code>with_redo</code>, which allows you to define the redo action similar to the getter/setter definition of <code>property</code>.</p> <pre><code>@magicclass\nclass A:\n    result = vfield(int)\n\n    def func(self, x: int):\n        old_result = self.result\n        result = self._very_heavy_task(x)\n        self.result = result\n\n        @undo_callback\n        def out():\n            self.result = old_result  # undo\n\n        @out.with_redo\n        def out():\n            self.result = result  # redo\n\n        return out\n</code></pre> <pre><code>ui = A()\nui.func(1)  # long-running task\nui.macro.undo()  # very fast\nui.macro.redo()  # very fast!!\n</code></pre>"},{"location":"make_better/undo/#best-practice-of-undoredo","title":"Best Practice of Undo/Redo","text":"<p>Undo/Redo should be called in GUI in most cases. Many applications map the key sequence <code>Ctrl+Z</code> to undo and <code>Ctrl+Y</code> to redo, or add tool buttons to do the same things.</p> <p>In <code>magicclass</code>, you can simply call <code>ui.macro.undo</code> and <code>ui.macro.redo</code> in the desired place. However, there are some points that you have to be careful about.</p> <ol> <li> <p>Do not macro-record undo/redo methods themselves.</p> <p>Recording undo/redo methods will block the undo stack from undo/redo execution.</p> <pre><code>from magicclass import do_not_record\n\n@magicclass\nclass A:\n    def func(self):\n        # do some undoable stuff\n\n    @do_not_record  # use this decorator to avoid recording\n    def undo(self):\n        self.macro.undo()\n\n    @do_not_record\n    def redo(self):\n        self.macro.redo()\n</code></pre> </li> <li> <p>Do not rely on the GUI state within the method.</p> <p>GUI state is the global state. Relying on the global state is very error prone. There's a bug in following code.</p> <pre><code>from magicclass import magicclass, vfield\nfrom magicclass.undo import undo_callback\n\n# widget that set \"value\" to \"inner_value\" when clicked.\n@magicclass\nclass A:\n    inner_value = vfield(int, record=False)\n    value = vfield(int, record=False)\n\n    def apply_value(self):\n        old_value = self.inner_value\n        self.inner_value = self.value\n        @undo_callback\n        def out():\n            self.inner_value = self.value = old_value\n        return out\n</code></pre> <p>The redo step will fail in following steps.</p> <ol> <li>Manually set <code>value</code> to 1.</li> <li>Click \"apply_value\" button. <code>inner_value</code> is now 1.</li> <li>Run <code>ui.macro.undo()</code>. Both <code>inner_value</code> and <code>value</code> are now 0.</li> <li>Run <code>ui.macro.redo()</code>. Since <code>value</code> is 0, <code>inner_value</code> is also 0 (redo fails).</li> </ol> <p>The reason is that <code>value</code> is a global state, which changes during undo/redo. To fix this, you can provide the value as a parameter to the method. The best way is to use the bind options.</p> <pre><code>from magicclass import magicclass, vfield\nfrom magicclass.undo import undo_callback\nfrom typing import Annotated\n\n@magicclass\nclass A:\n    inner_value = vfield(int, record=False)\n    value = vfield(int, record=False)\n\n    def apply_value(self, value: Annotated[int, {\"bind\": value}]):\n        old_value = self.inner_value\n        self.inner_value = self.value = value\n        @undo_callback\n        def out():\n            self.inner_value = self.value = old_value\n        return out\n</code></pre> </li> <li> <p>Make sure the recorded macro is executable.</p> <p>If you don't use custom redo actions, the redo operation fully relies on the macro string. If the macro string is not executable, the redo operation will fail. In following example, redo does not work.</p> <pre><code>import numpy as np\nfrom magicclass import magicclass, set_options, vfield\nfrom magicclass.undo import undo_callback\n\ndef get_array(*_):\n    return np.arange(10)\n\n@magicclass\nclass A:\n    array = vfield(str, record=False)\n\n    @set_options(x={\"bind\": get_array})\n    def show_array(self, x):\n        old_str = self.array\n        self.array = str(x)\n        @undo_callback\n        def out():\n            self.array = old_str\n        return out\n</code></pre> <p><code>macro-kit</code> does not implement the object-to-string conversion for <code>numpy.ndarray</code> by default because the array data can potentially be very large. To avoid this, you can pass a list to the method.</p> <pre><code>...\n\ndef get_array(*_):\n    return list(range(10))\n\n@magicclass\nclass A:\n    array = vfield(str, record=False)\n\n    @set_options(x={\"bind\": get_array})\n    def show_array(self, x):\n        old_str = self.array\n        self.array = str(np.asarray(x))\n        @undo_callback\n        def out():\n            self.array = old_str\n        return out\n</code></pre> </li> </ol>"},{"location":"make_better/validator/","title":"Validation/Normalization for Macro Recording","text":"<p>In Python, argument validation and normalization are very easy.</p> <pre><code>def func(arg1, arg2, arg3):\n    arg1, arg2, arg3 = _normalize_input(arg1, arg2, arg3)\n    # do something\n</code></pre> <p>However, normalization is always done in the function body, so that the arguments are not normalized yet when macro expression is created. This behavior sometimes affects the reproducibility. For example, if you pass <code>None</code> as the default argument and changed the default behavior later, recorded macro will change its behavior in the newer version:</p> <pre><code>from magicclass import magicclass\nfrom magicclass.types import Optional\n\n@magicclass\nclass Main:\n    # in version 0.1\n    def _normalize_i(self, i):\n        if i is not None:\n            return i\n        return 1\n\n    # in version 0.2\n    def _normalize_i(self, i):\n        if i is not None:\n            return i\n        return 2\n\n    def f(self, i: Optional[int] = None):\n        i = self._normalize_i(i)\n        print(i)\n\nui = Main()\nui.f()  # macro is \"f(i=None)\"\n</code></pre> <p><code>magic-class</code> extends the typing system of <code>magicgui</code> to support the \"validator\" key in <code>Annotated</code> types. The validator will be called on the passed argument before macro creation.</p> <pre><code>@magicclass\nclass Main:\n    ...\n\n    def f(self, i: Annotated[Optional[int], {\"validator\": _normalize_i}] = None):\n        print(i)\n\nui = Main()\nui.f()  # macro is \"f(i=1)\" for v0.1 and \"f(i=2)\" for v0.2\n</code></pre> <p>Validators can accept the third argument, where a dictionary of all the arguments will be passed. This is useful when you want to normalize the arguments based on other arguments.</p> <pre><code>@magicclass\nclass Main:\n    def _normalize_i(self, i, values):\n        if i is not None:\n            return i\n        return values[\"j\"]\n\n    def f(\n        self,\n        i: Annotated[Optional[int], {\"validator\": _normalize_i}] = None,\n        j: int = 1,\n    ):\n        # if i is not given, use j instead\n        print(i, j)\n</code></pre>"},{"location":"make_better/workers/","title":"Multi-threading","text":"<p>Multi-threading is an important idea in GUI development. If you want to implement background execution or progress bar, you'll usually have to rely on multi-threading.</p> <p><code>thread_worker</code> makes multi-threaded implementation much easier, without rewriting the existing single-threaded code. It is available in:</p> <pre><code>from magicclass.utils import thread_worker\n</code></pre> <p>Note</p> <p>It is named after the <code>thread_worker</code> function originally defined in <code>superqt</code> and <code>napari</code>, which create a new function that will return a \"worker\" of the original function.</p> <pre><code>from napari.utils import thread_worker\n\n@thread_worker\ndef func():\n    # do something\n\nworker = func()  # worker is ready to run the original \"func\"\nworker.start()  # the original \"func\" actually get called\n</code></pre> <p>On the other hand, <code>magic-class</code>'s <code>thread_worker</code> is a class. It returns a <code>thread_worker</code> object instead of a new function. A <code>thread_worker</code> object will create a function that will start a worker every time it is accessed via <code>self.func</code>. Although they are designed differently, they share very similar API.</p>"},{"location":"make_better/workers/#basic-usage","title":"Basic Usage","text":"<p>Decorate the methods you want to be multi-threaded and that's it!</p> <pre><code>import time\nfrom magicclass import magicclass\nfrom magicclass.utils import thread_worker\n\n@magicclass\nclass Main:\n    @thread_worker\n    def func(self):\n        for i in range(10):\n            time.sleep(0.2)  # time consuming function\n            print(i)\n\nui = Main()\nui.show()\n</code></pre> <p></p> <p>During execution of <code>func</code>, the GUI window will not get frozen because function is running in another thread.</p> <p>Note</p> <p>If you are running functions programatically, GUI window will be disabled as usual. This is because the <code>run</code> method of <code>QRunnable</code> is called in the main thread, otherwise the second line of code will be executed before the first line of code actually finishes.</p> <pre><code>@magicclass\nclass Main:\n    @thread_worker\n    def f0(self):\n        ...\n    @thread_worker\n    def f1(self):\n        ...\n\nui = Main()\nui.f0()\nui.f1()  # this function will be called before f0 finishes\n</code></pre> <p>This behavior is important to keep manual and programatical execution consistent.</p> <p>If decorated method is a generator, worker will iterate over it until it ends. In the following example:</p> <pre><code>import time\nfrom magicclass import magicclass\nfrom magicclass.utils import thread_worker\n\n@magicclass\nclass Main:\n    @thread_worker\n    def func(self):\n        for i in range(3):\n            print(i)\n            yield i\n\nui = Main()\nui.show()\n</code></pre> <p>after you click the \"func\" button you'll get output like this.</p> Output<pre><code>0\n1\n2\n</code></pre>"},{"location":"make_better/workers/#connect-callbacks","title":"Connect Callbacks","text":"<p>If you update widgets in a <code>thread_worker</code>, GUI crashes.</p> <pre><code>import time\nfrom magicclass import magicclass, vfield\nfrom magicclass.utils import thread_worker\n\n@magicclass\nclass Main:\n    yielded_value = vfield(str)\n    returned_value = vfield(str)\n\n    @thread_worker\n    def func(self, n: int = 10):\n        for i in range(n):\n            self.yielded_value = str(i)\n            time.sleep(0.3)\n        self.returned_value = \"finished\"  # updates the widget\n\nui = Main()\nui.show()\n</code></pre> <p>This is because updating widgets must be done in the main thread but <code>thread_worker</code> is executed in a separate thread.</p> <p>Just like <code>superqt</code> and <code>napari</code>, you can connect callback functions to <code>thread_worker</code> objects. These callback functions are called in the main thread so that you can update widgets safely.</p> <p>There are six types of callbacks.</p> <ul> <li><code>started</code> ... called when worker started.</li> <li><code>returned</code> ... called when worker returned some values.</li> <li><code>errored</code> ... called when worker raised an error.</li> <li><code>yielded</code> ... called when worker yielded values.</li> <li><code>finished</code> ... called when worker finished.</li> <li><code>aborted</code> ... called when worker was aborted by some reasons.</li> </ul> <p>Following example shows how you can update widget every 0.3 second.</p> <pre><code>import time\nfrom magicclass import magicclass, vfield\nfrom magicclass.utils import thread_worker\n\n@magicclass\nclass Main:\n    yielded_value = vfield(str)\n    returned_value = vfield(str)\n\n    @thread_worker\n    def func(self, n: int = 10):\n        for i in range(n):\n            yield str(i)\n            time.sleep(0.3)\n        return \"finished\"\n\n    @func.yielded.connect\n    def _on_yield(self, value):\n        self.yielded_value = value\n\n    @func.returned.connect\n    def _on_return(self, value):\n        self.returned_value = value\n\nui = Main()\nui.show()\n</code></pre>"},{"location":"make_better/workers/#better-way-to-define-callbacks","title":"Better Way to Define Callbacks","text":"<p>The <code>returned</code> callbacks and the <code>yielded</code> callbacks are very useful for letting users know the progress and results of the function. However, a problem occurs when you send a lot of information to the callback funcition.</p> <pre><code>import time\nfrom magicclass import magicclass, vfield\nfrom magicclass.utils import thread_worker\n\n@magicclass\nclass Main:\n    result_1 = vfield(str)\n    result_2 = vfield(str)\n    result_3 = vfield(str)\n\n    @thread_worker\n    def func(self, a: int, b: int):\n        r1 = very_heavy_computation_1(a, b)\n        r2 = very_heavy_computation_2(a, b)\n        r3 = very_heavy_computation_3(a, b)\n        return r1, r2, r2\n\n    @func.returned.connect\n    def _on_return(self, value):\n        r1, r2, r3 = value  # hmmm...\n        self.result_1 = r1\n        self.result_2 = r2\n        self.result_3 = r3\n\nui = Main()\nui.show()\n</code></pre> <p>You'll have to return all the values required for updating the widgets. In terms of readability, this code is awful. You also have to annotate the second argument of <code>_on_return</code> with a very long <code>tuple[...]</code> type.</p> <p>Here, you can use <code>thread_worker.callback</code> static method. This method converts a function into a <code>Callback</code> object, which will be called if a thread worker detected it as a returned/yielded value.</p> <pre><code>import time\nfrom magicclass import magicclass, vfield\nfrom magicclass.utils import thread_worker\n\n@magicclass\nclass Main:\n    result_1 = vfield(str)\n    result_2 = vfield(str)\n    result_3 = vfield(str)\n\n    @thread_worker\n    def func(self, a: int, b: int):\n        r1 = very_heavy_computation_1(a, b)\n        r2 = very_heavy_computation_2(a, b)\n        r3 = very_heavy_computation_3(a, b)\n\n        # write things in a function\n        @thread_worker.callback\n        def _return_callback():\n            self.result_1 = r1\n            self.result_2 = r2\n            self.result_3 = r3\n        return _return_callback\n\n    @thread_worker\n    def gen(self):\n        @thread_worker.callback\n        def _yield_callback():\n            # r1, r2, r3 are non-local variables\n            self.result_1 = r1\n            self.result_2 = r2\n            self.result_3 = r3\n        for a in range(5):\n            r1 = very_heavy_computation_1(a, 0)\n            r2 = very_heavy_computation_2(a, 0)\n            r3 = very_heavy_computation_3(a, 0)\n            yield _yield_callback\n\nui = Main()\nui.show()\n</code></pre>"},{"location":"make_better/workers/#use-progress-bar","title":"Use Progress Bar","text":""},{"location":"make_better/workers/#how-to-use-it","title":"How to use it?","text":"<p>Just like <code>napari</code>, you can use the embeded progress bar to display the progress of the current function call using <code>progress=...</code> argument. Same options are available in <code>magic-class</code> but you can choose which progress bar to use.</p> <ol> <li> <p>If the main window does not have <code>magicgui.widgets.ProgressBar</code> widget, a popup    progress bar widget will be created.</p> <pre><code>@magicclass\nclass Main:\n    @thread_worker(progress={\"total\": 10})\n    def func(self):\n    for i in range(10):\n        time.sleep(0.1)\n</code></pre> </li> <li> <p>If the main window has at least one <code>magicgui.widgets.ProgressBar</code> widget, the first    one will be used.</p> <pre><code>@magicclass\nclass Main:\n    pbar = field(ProgressBar)\n    @thread_worker(progress={\"total\": 10})\n    def func(self):\n    for i in range(10):\n        time.sleep(0.1)\n</code></pre> </li> <li> <p>If \"pbar\" option is given, progress bar specified by this option will be used.</p> <pre><code>@magicclass\nclass Main:\n    pbar1 = field(ProgressBar)\n    pbar2 = field(ProgressBar)\n\n    @thread_worker(progress={\"total\": 10, \"pbar\": pbar1})\n    def func(self):\n        for i in range(10):\n            time.sleep(0.1)\n</code></pre> </li> </ol>"},{"location":"make_better/workers/#how-to-set-proper-total-iteration-numbers","title":"How to set proper total iteration numbers?","text":"<p>I most cases, iteration numbers vary between function calls depending on the widget states. In <code>magic-class</code>, you can pass a function or an evaluable literal string to the \"total\" argument.</p> <pre><code>@magicclass\nclass Main:\n    # Use a getter function.\n\n    def _get_total(self):\n        return 10\n\n    @thread_worker(progress={\"total\": _get_total})\n    def func0(self):\n        n_iter = self._get_total()\n        for i in range(n_iter):\n            time.sleep(0.1)\n            yield\n\n    # Use a literal. Only the function arguments are available in the namespace.\n\n    @thread_worker(progress={\"total\": \"n_iter\"})\n    def func1(self, n_iter: int = 10):\n        for i in range(n_iter):\n            time.sleep(0.1)\n            yield\n\n    # Use a literal. Any evaluable literal can be used.\n\n    @thread_worker(progress={\"total\": \"width * height\"})\n    def func2(self, width: int = 3, height: int = 4):\n        for w in range(width):\n            for h in range(height):\n                print(w * h, end=\", \")\n                time.sleep(0.1)\n                yield\n            print()\n\n    # Use a literal. Of course, \"self\" is the most powerful way.\n\n    n = field(int)\n\n    @thread_worker(progress={\"total\": \"self.n.value\"})\n    def func3(self):\n        for i in range(self.n.value):\n            time.sleep(0.1)\n            yield\n</code></pre>"},{"location":"make_better/workers/#better-way-to-pass-progress-bar-parameters","title":"Better way to pass progress bar parameters","text":"<p>Parameteres for the progress bar should be passed as a dictionary. This is not good for many reasons such as readability and type hinting. You can use <code>with_progress</code> method for the progress bar configuration.</p> <pre><code>@magicclass\nclass Main:\n    # instead of `@thread_worker(progress={\"total\": 10})`\n    @thread_worker.with_progress(total=10)\n    def func(self):\n    for i in range(10):\n        time.sleep(0.1)\n</code></pre>"},{"location":"make_better/workers/#nesting-thread_worker","title":"Nesting <code>thread_worker</code>","text":"<p>To reuse thread worker functions, you would want to nest them. However, this should be done carefully. If the nested thread worker updates the widget, the outer thread worker crashes the GUI.</p> <pre><code>@magicclass\nclass Main:\n    @thread_worker\n    def outside(self):\n        self.inside()  # This line will crash the GUI, even though\n        # the function that update the widget is in the callback of\n        # `self.inside`.\n        # When a thread worker is called programatically, the function\n        # body and the callbacks are all called in the main thread.\n        # This means that even `self.function_that_update_widget` is\n        # called inside this method.\n\n    @thread_worker\n    def inside(self):\n        self.very_heavy_computation()\n        return thread_worker.callback(self.function_that_update_widget)\n</code></pre>"},{"location":"make_better/workers/#a-naive-solution","title":"A naive solution","text":"<p>One way to avoid this is to use <code>thread_worker.callback</code>.</p> <pre><code>@magicclass\nclass Main:\n    @thread_worker\n    def outside(self):\n        # self.inside() will be called as as callback so it won't crash the GUI\n        return thread_worker.callback(self.inside)\n\n    @thread_worker\n    def inside(self):\n        self.very_heavy_computation()\n        return thread_worker.callback(self.function_that_update_widget)\n</code></pre>"},{"location":"make_better/workers/#better-but-advanced-solution","title":"Better but advanced solution","text":"<p>Methods decorated with <code>thread_worker</code> have a <code>arun</code> attribute, which will run the function in a non-blocking way (asynchronously). More precisely, <code>arun</code> will return a generator that convert all the yielded and returned value into yielded values. This means that you can use <code>yield from</code> to send all the callbacks of the nested thread worker to the outer thread worker.</p> <pre><code>@magicclass\nclass Main:\n    @thread_worker\n    def outside(self):\n        # `arun` takes the same arguments as the original function.\n        yield from self.inside.arun(1)\n\n    @thread_worker\n    def inside(self, i: int):\n        self.function_that_update_widget()\n</code></pre>"},{"location":"make_better/workers/#asynchronous-valuewidget-callbacks","title":"Asynchronous ValueWidget Callbacks","text":"<p>Warning</p> <p>This feature is experimental. It may not work in some cases.</p> <p>Fields are equipped with <code>connect</code> method to connect callbacks to them.</p> <pre><code>@magicclass\nclass Main:\n    x = field(int)\n\n    @x.connect\n    def _x_changed(self, value):\n        print(value)  # print the new value every time it changes\n</code></pre> <p>Then, what if the callback function is computationally expensive? The GUI will freeze during the execution, which makes user experience very bad. This problem is prominent when you want to implement functions like below.</p> <ul> <li>Image sweeping ... images are large collections of data. Updating the image while   moving a slider widget will be very slow.</li> <li>Data fetching ... Fetching data from the internet is slower compared to updating   widgets locally.</li> </ul> <p><code>connect_async</code> is a method that connects a callback function as a <code>thread_worker</code> with proper configurations. All the rules follows the standard <code>thread_worker</code> method.</p> <pre><code>@magicclass\nclass Main:\n    x = field(int)\n    display = field(str)\n\n    @x.connect_async\n    def _x_changed(self, value):\n        # If you want to update the widget, you have to use yield/return\n        # callbacks.\n        yield f\"updating ...\"\n        time.sleep(1)\n        return f\"changed to {value}\"\n\n    @_x_changed.yielded.connect\n    @_x_changed.returned.connect\n    def _update(self, text: str):\n        self.display.value = text\n</code></pre> <p>To avoid running widget callback functions multiple times, you can pass <code>timeout</code> argument to <code>connect_async</code>. If the previous run is still ongoing, it will be aborted if the new run is started within the timeout period. <code>timeout=0</code> means that the previous run will never be aborted, and <code>timeout=float(\"inf\")</code> means that the previous run will be always aborted if not finished.</p> <pre><code>@magicclass\nclass Main:\n    ...\n\n    @x.connect_async(timeout=0.1)\n    def _x_changed(self, value):\n        ...\n</code></pre>"},{"location":"visualization/","title":"Data Visualization","text":"<p>Data visualization is one of the main reasons why we have to rely on GUIs. <code>magic-class</code> has prepared some custom magic widgets (widgets that follow <code>magicgui</code> protocols) that can directly used as components of your GUI.</p> <ul> <li><code>matplotlib</code></li> <li><code>pyqtgraph</code></li> <li><code>vispy</code></li> <li><code>vtk</code></li> </ul>"},{"location":"visualization/matplotlib/","title":"Matplotlib Figure","text":"<p>matplotlib is one of the most widely used data visualization libraries. I guess most  of the Python users know the basics of the library.</p> <p>For data visualization of simple data set, your can use the <code>Figure</code> widget.</p> <pre><code>from magicclass.widgets import Figure\n</code></pre> <p>It has very simple API inherited from the original functions, such as <code>plt.plot(x, y)</code> or <code>plt.xlim(0, 100)</code>. It also support interactive plot.</p>"},{"location":"visualization/matplotlib/#basic-usage","title":"Basic Usage","text":"<p>If you are using <code>Figure</code> widget independent of <code>magic-class</code>, it's just like the usual <code>matplotlib</code> way.</p> <pre><code># run \"%gui qt\" if needed\nplt = Figure()\nplt.plot(np.random.random(100))\nplt.show()\n</code></pre> <p>Many functions defined in <code>matplotlib.pyplot</code> are also supported.</p> <pre><code>plt.xlim(-5, 5)  # change x-limits\nplt.hist(np.random.normal(size=100), color=\"r\")  # histogram\nplt.imshow(np.random.random((64, 64)), cmap=\"gray\")  # 2D image\nplt.xlabel(\"X label\")  # change x-label\nplt.title(\"title\")  # change title\nplt.xticks([0, 1], [\"start\", \"end\"])  # change x-tick labels\n</code></pre> <p>If you want to clear the contents, call <code>cla()</code> method.</p> <pre><code>plt.cla()\n</code></pre>"},{"location":"visualization/matplotlib/#use-figure-widget-in-magic-class","title":"Use Figure Widget in Magic Class","text":"<p>In most cases, you'll use <code>field</code> to create a <code>matplotlib</code> figure widget in your GUI.</p> <pre><code>from magicclass import magicclass, field\n\n@magicclass\nclass Main:\n    plt = field(Figure)\n\n    def plot(self):\n        self.plt.plot(np.random.random(100))\n</code></pre>"},{"location":"visualization/matplotlib/#use-multiple-axes","title":"Use Multiple Axes","text":"<p>Sometimes we have to prepare multiple axes and plot different sets of data separately by using <code>fig, ax = plt.subplots(2, 1)</code> or other similar methods. The <code>Figure</code> widget also support multi-axes plotting. You can create a multi-axes widget by passing <code>nrows</code> and <code>ncols</code> arguments to it, like <code>plt.subplots</code>, and all the axes are accessible via <code>axes</code> attribute. However, since <code>axes</code> are the <code>matplotlib</code>'s <code>Axes</code> object itself, you'll have to call <code>draw</code> method to update the figure.</p> <pre><code>plt = Figure(nrows=1, ncols=2)\nplt.axes[0].plot([1, 2, 3])  # the first axis\nplt.axes[1].plot([1, 4, 2])  # the second axis\nplt.draw()  # update\n</code></pre> <pre><code>@magicclass\nclass Main:\n    plt = field(Figure, options={\"nrows\": 1, \"ncols\": 2})\n</code></pre>"},{"location":"visualization/matplotlib/#plot-api","title":"Plot API","text":"<p>For the simplest usage, you can use <code>plot_api</code> submodule. Its API is almost identical to those in <code>matplotlib.pyplot</code>.</p> <pre><code># instead of import matplotlib.pyplot as plt\nimport magicclass.plot_api as plt\n\nplt.figure()\nplt.plot([0, 1, 2, 3], [4, 2, 3, 1], color=\"red\")\nplt.show()\n</code></pre> <p>The current figure widget is available with <code>gcw()</code> function. It returns the <code>magicclass.widgets.Figure</code> widget.</p> <pre><code># add figure to a widget.\nfrom magicgui.widgets import Container\n\nfig = plt.gcw()\ncnt = Container(widgets=[fig])\ncnt.show()\n</code></pre>"},{"location":"visualization/pyqtgraph/","title":"PyQtGraph Canvas","text":"<p>PyQtGraph is a data visualization library based on Qt. It provides variety of plot canvases and plot items that can be operated in a interactive way. The <code>magicclass.ext.pyqtgraph</code> submodule tries to integrate many of the <code>pyqtgraph</code> widgets to provide a  consistent, <code>magicgui</code>-like API.</p> <p>You have to install <code>pyqtgraph</code> in advance.</p> <pre><code>pip install pyqtgraph\n</code></pre> <p>Then several <code>pyqtgraph</code> canvases are now available.</p> <pre><code>from magicclass.ext.pyqtgraph import QtPlotCanvas  # 1-D plot, like plt.plot\nfrom magicclass.ext.pyqtgraph import QtMultiPlotCanvas  # multiple QtPlotCanvas\nfrom magicclass.ext.pyqtgraph import QtImageCanvas  # 2-D image, like plt.imshow\nfrom magicclass.ext.pyqtgraph import QtMultiImageCanvas  # multiple QtImageCanvas\n</code></pre>"},{"location":"visualization/pyqtgraph/#qtplotcanvas","title":"QtPlotCanvas","text":"<p><code>QtPlotCanvas</code> is a canvas for 1-D plotting.</p> <pre><code>from magicclass.ext.pyqtgraph import QtPlotCanvas\n\ncanvas = QtPlotCanvas()\ncanvas.show()\n</code></pre> <p>A <code>QtPlotCanvas</code> is composed of several \\\"layers\\\" and each layer corresponds to a plot item that is in the canvas. Basically you\\'ll add new layers to visualize data.</p>"},{"location":"visualization/pyqtgraph/#methods-and-attributes","title":"Methods and Attributes","text":"<ul> <li>Major methods<ul> <li><code>add_curve()</code> ... Add a curve possibly with symbols, similar to <code>plt.plot</code>.</li> <li><code>add_scatter()</code> ... Add scatter plot item, similar to <code>plt.scatter</code>.</li> <li><code>add_hist()</code> ... Build a histogram from input data, similar to <code>plt.hist</code>.</li> <li><code>add_bar()</code> ... Add a bar plot, similar to <code>plt.bar</code>.</li> <li><code>add_infline()</code> ... Add a infinite line, similar to <code>plt.axline</code>.</li> <li><code>add_text()</code> ... Add list of texts, similar to <code>plt.text</code>.</li> <li><code>show()</code> ... Show canvas.</li> </ul> </li> <li>Major attributes and properties<ul> <li><code>layers</code> ... List of all the layers.</li> <li><code>visible</code> ... Visibility of canvas.</li> <li><code>enabled</code> ... Interactivity of canvas.</li> <li><code>xlim</code> ... Minumum and maximum value of x-axis in viewbox.</li> <li><code>ylim</code> ... Minumum and maximum value of y-axis in viewbox.</li> <li><code>xlabel</code> ... Label text of x-axis.</li> <li><code>ylabel</code> ... Label text of y-axis.</li> <li><code>title</code> ... Title text of the plot canvas.</li> <li><code>legend</code> ... Legend item of the canvas.</li> <li><code>mouse_click_callbacks</code> ... list of callback functions that will get called on   mouse click.</li> </ul> </li> </ul>"},{"location":"visualization/pyqtgraph/#add-curves","title":"Add curves","text":"<p><code>add_curve</code> method will add a <code>Curve</code> layer to the canvas, store the layer in the <code>layers</code> attribute and return the layer.</p> <pre><code>xdata = np.linspace(0, np.pi, 200)\nydata = np.sin(xdata) * np.exp(-xdata)\nlayer = canvas.add_curve(xdata, ydata)  # or canvas.add_curve(ydata) if you don't need x scale.\n</code></pre> <p>There are other keyword argument that will be useful to visualize differently.</p> <pre><code>canvas.add_curve(xdata, ydata, name=\"Data-1\")  # name of the layer\ncanvas.add_curve(xdata, ydata, edge_color=\"yellow\")  # change color\ncanvas.add_curve(xdata, ydata, lw=4, ls=\"--\")  # change line width and line style\ncanvas.add_curve(xdata, ydata, symbol=\"+\")  # show symbol at the data points\n</code></pre> <p>Layer is available in <code>layers</code>.</p> <pre><code>layer = canvas.layers[0]  # the first layer\n</code></pre>"},{"location":"visualization/pyqtgraph/#handle-layers","title":"Handle layers","text":"<p>The layer objects are also designed to be easily</p> <ol> <li> <p>Show/hide layer</p> <pre><code>layer.visible = True  # show\nlayer.visible = False  # hide\n</code></pre> </li> <li> <p>Change color</p> <pre><code>layer.face_color = \"red\"  # str\nlayer.face_color = [0.4, 0.2, 0.2, 1.0]  # float RGBA\nlayer.edge_color = [0.4, 0.2, 0.2, 1.0]  # change edge color\nlayer.color = \"white\"  # change face color and edge color\n</code></pre> </li> <li> <p>Get data</p> <pre><code>layer.xdata  # the x data\nlayer.ydata  # the y data\n</code></pre> </li> </ol>"},{"location":"visualization/pyqtgraph/#qtmultiplotcanvas","title":"QtMultiPlotCanvas","text":"<p><code>QtMultiPlotCanvas</code> is a collection of <code>QtPlotCanvas</code>.</p> <pre><code>from magicclass.ext.pyqtgraph import QtMultiPlotCanvas\n\ncanvas = QtMultiPlotCanvas(1, 2)  # 1 x 2 canvases\ncanvas.show()\n</code></pre> <p>If you want to synchronize axes movements, set <code>sharex</code> and <code>sharey</code>.</p> <pre><code>canvas = QtMultiPlotCanvas(2, 2, sharex=True, sharey=True)\n</code></pre> <p>The i-th canvas is available by simple indexing. Returned items have the same API as <code>QtPlotCanvas</code>.</p> <pre><code>canvas[0].add_curve(np.random.random(100))  # add curve to the 0-th canvas.\ncanvas[1].layers  # Layer list of the 1st canvas.\n</code></pre>"},{"location":"visualization/vispy/","title":"Vispy Canvas","text":"<p>vispy is a 2D/3D visualization library that has Qt backend.</p> <p>Warning</p> <p>This submodule is largely work in progress!</p>"},{"location":"visualization/vispy/#2d-canvas","title":"2D Canvas","text":"<p>For 2D plot, use <code>VispyPlotCanvas</code>.</p> <pre><code>from magicclass.ext.vispy import VispyPlotCanvas\nfrom magicclass import magicclass, field\n\n@magicclass\nclass A:\n    canvas = field(Vispy3DCanvas)\n\nui = A()\nui.canvas.add_curve(np.random.random(100), color=\"red\", symbol=\"+\")\nui.show()\n</code></pre>"},{"location":"visualization/vispy/#3d-canvas","title":"3D Canvas","text":"<p>For 3D visualization, use <code>Vispy3DCanvas</code>.</p> <pre><code>from magicclass.ext.vispy import Vispy3DCanvas\nfrom magicclass import magicclass, field\n\n@magicclass\nclass A:\n    canvas = field(Vispy3DCanvas)\n\nui = A()\nui.canvas.add_image(np.random.random((60, 60, 60)))\nui.show()\n</code></pre> <p>You can programatically adjust parameters</p> <pre><code>ui.canvas.layers[0].contrast_limits = (0.2, 0.7)\n</code></pre> <p>or create a <code>Container</code> widget of parameters.</p> <pre><code>params = ui.canvas.layers[0].as_container()  # create a Container\nparams.show()  # show the widget\n</code></pre>"},{"location":"visualization/vispy/#supported-methods","title":"Supported Methods","text":"<ul> <li><code>add_image</code> ... Add a 3D array as a volume.</li> <li><code>add_isosurface</code> ... Add a 3D array as a isosurface.</li> <li><code>add_surface</code> ... Add a list of 2D arrays as a surface.</li> <li><code>add_points</code> ... Add a (N, 3) array as a point cloud.</li> <li><code>add_arrows</code> ... Add a (N, P, 3) array as arrows. P is the number of points per arrow.</li> </ul>"},{"location":"visualization/vtk/","title":"VTK (Visualization Toolkit)","text":"<p>VTK (Visualization Toolkit) is a module for interactive visualization of 3D graphics. <code>magic-class</code> supports basic VTK functionalities in <code>magicclass.ext.vtk</code>.</p> <pre><code>from magicclass.ext.vtk import VtkCanvas\n</code></pre> <p>TODO</p>"}]}